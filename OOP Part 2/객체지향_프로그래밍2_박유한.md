# 객체지향 프로그래밍 I

1. [return문](#return문)  
2. [static 메서드와 인스턴스 메서드](#static 메서드와 인스턴스 메서드)  
3. [오버로딩(overloading)](#오버로딩(overloading)  
4. [생성자(constructor)](#생성자(constructor))
5. [변수의 초기화](#변수의 초기화)


## return문
- return 문은 현재 실행 중인 메서드를 종료하고 호출한 메서드로 되돌아가는 역할을 합니다. 모든 메서드에는 적어도 하나의 return 문이 있어야 하지만, 반환 타입이 void인 경우는 예외입니다. 
- 이런 경우에는 return 문 없이도 컴파일러가 메서드의 마지막에 return;을 자동적으로 추가해주기 때문에 문제가 없습니다.

- 예를 들면, 다음과 같은 경우입니다.

```java
void method() {
    int x = 10;
    int y = 20;

    int sum = x + y;

    System.out.println("합계: " + sum);
}
```

-위의 코드에서는 반환값이 없는 void 메서드이므로, return문이 별도로 작성되지 않았습니다. 이런 경우, 컴파일러는 자동으로 메서드 끝에 return문을 추가하므로, 메서드가 종료되면 호출한 곳으로 제어가 돌아갑니다.

그러나 반환타입이 void가 아닌 경우에는 retun문이 있어야 합니다. retun문이 없으면 컴파일 에러(error: missing return statement)가 발생합니다.
```java
int multiply(int x, int y) { int result = x * y;
return result; // 반환 타입이 void가 아니므로 생략불가 
}
```

### 반환값

- 반환값은 메서드의 작업 결과를 호출한 곳으로 보내주는 역할을 하는 값입니다. `return` 문은 메서드의 실행을 종료하고, 해당 메서드를 호출한 곳으로 값을 돌려줍니다.
- 반환값은 주로 변수가 사용되지만, 항상 그럴 필요는 없습니다. 

예를 들어, 두 수의 합을 반환하는 메서드에서는 'x+y'라는 식이 `return` 문의 반환값으로 쓰일 수 있습니다. 이 경우, 실제로 반환되는 것은 수식이 아니라 이 수식을 계산한 결과입니다.
```java
int intAdd(int x, int y) {
        return x + y;
    }
```

- 단순한 메서드의 경우 `if-else` 문 대신 조건 연산자를 사용하여 결과를 반환할 수 있습니다. 예를 들어, 입력받은 정수의 절대값을 반환하는 메서드에서는 조건 연산자를 사용하여 음수일 경우 양수로 반환할 수 있습니다.
```java
int abs(int x) {
return x>=0 ? x : -x;
)
```

### 호출스택


- 호출 스택은 메서드의 작업에 필요한 메모리 공간을 제공합니다. 메서드가 호출되면 해당 메서드를 위한 메모리가 호출 스택에 할당되며, 
- 이 메모리는 메서드가 작업을 수행하는 동안 **지역 변수**와 **연산의 중간 결과** 등을 저장하는 데 사용됩니다.
- 메서드의 작업이 완료되면 할당된 메모리 공간은 반환되어 비워집니다.

아래는 호출 스택의 예제 입니다:

```java
class CallStackTest {
	public staic void main(String[] args) {
    	firstMethod();
    }
    static void firstMethod() {
    	secondMethod();
    }
    static void secondMethod() {
    	System.out.println("secondMethod()");
    }
}
```

![Alt Text](https://velog.velcdn.com/images%2Fjeong11%2Fpost%2F1d1e2c1c-de11-4ca9-9649-c2135a25af9b%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-29%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.28.17.png)

- 메서드가 호출되면 수행에 필요한 메모리를 호출 스택에 할당받습니다.
메서드가 수행을 마치면 사용한 메모리를 반환하고 스택에서 제거됩니다.
호출 스택의 맨 위에 있는 메서드가 현재 실행 중인 메서드이며, 나머지 메서드들은 대기 중인 상태입니다.
아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드입니다.

### 기본형 매개변수와 참조형 매개변수
- 기본형 매개변수 변수의 값을 읽기만 할 수 있습니다다.(read only) 
기본형 매개변수는 변수의 값을 읽기만 할 수 있습니다. 이는 매개변수로 전달된 값이 메서드 내에서 읽기만 가능하며, 해당 메서드에서 값을 변경해도 호출한 쪽에는 영향을 주지 않습니다. 기본형 매개변수는 값에 대한 복사본을 전달받기 때문에 메서드 내에서 값을 변경해도 호출한 쪽에는 영향을 주지 않습니다.

- 참조형 매개변수 변수의 값을 읽고 변경할 수 있습니다.(read & write)
참조형 매개변수는 변수의 값을 읽고 변경할 수 있습니다. 매개변수로 전달된 참조형 객체는 실제 객체를 가리키는 주소를 전달받기 때문에 메서드 내에서 해당 객체의 값을 읽고 변경할 수 있습니다. 따라서, 참조형 매개변수는 메서드 내에서 객체의 내부 상태를 수정할 수 있으며, 이로 인해 호출한 쪽에도 변경된 값이 반영됩니다.

- 참조형 반환타입
매개변수뿐만 아니라 반환타입도 참조형이 될 수 있습니다.
반환타입이 참조형이라는 것(반환 하는 값의 타입이 참조형)은 메서드가 객체의 주소를 반환한다는 의미입니다. 참조형 반환타입은 객체의 주소를 반환하므로 실제로는 정수값인 주소가 반환되는 것이지만, 일반적으로는 객체를 가리키는 참조로 사용됩니다.



## static 메서드와 인스턴스 메서드

- static 메서드: 클래스가 로딩될 때 메모리에 할당되며, 객체 생성 없이 클래스 이름만으로 호출할 수 있는 메서드입니다. static 메서드 내에서는 인스턴스 변수나 인스턴스 메서드를 직접 사용할 수 없습니다.
static 메서드:

static 메서드는 클래스가 로딩될 때 메모리에 할당됩니다. 즉, 해당 클래스의 인스턴스 생성 없이도 클래스 이름만으로 호출할 수 있습니다.
static 메서드는 주로 유틸리티 메서드나 독립적인 기능을 제공하는 메서드로 사용됩니다.
static 메서드 내에서는 인스턴스 변수나 인스턴스 메서드를 직접 사용할 수 없습니다. 즉, this 키워드를 사용할 수 없습니다.

```java
public class Test {
    static void staticMethod() {
        System.out.println("This is a static method.");
    }
}

Test.staticMethod(); // 클래스 이름으로 메서드 호출
```

static 키워드를 언제 사용해야 하는지에 대한 내용은 다음과 같습니다:

1. 클래스를 설계할 때, 모든 인스턴스에서 공통으로 사용하는 멤버변수에 static을 붙입니다.
   - 각 인스턴스는 독립적이기 때문에 인스턴스 변수(iv)는 서로 다른 값을 유지합니다. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static으로 정의하여 클래스 변수로 만듭니다.

2. 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있습니다.
   - static으로 선언된 변수(클래스 변수)는 클래스가 메모리에 로드될 때 자동으로 생성되기 때문에 인스턴스를 생성하지 않아도 사용할 수 있습니다.

3. 클래스 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없습니다.
   - 인스턴스 변수는 인스턴스가 존재해야만 사용할 수 있지만, 클래스 메서드(static으로 선언된 메서드)는 인스턴스 생성 없이 호출될 수 있습니다. 따라서 클래스 메서드에서는 인스턴스 변수의 사용이 금지됩니다. 반면, 인스턴스 변수나 인스턴스 메서드에서는 언제든지 static으로 선언된 멤버를 사용할 수 있습니다. 인스턴스 변수가 존재한다는 것은 static 변수가 이미 메모리에 존재한다는 것을 의미합니다.

4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static을 고려해야 합니다.
   - 메서드의 작업 내용 중에서 인스턴스 변수가 필요하지 않다면 해당 메서드에 static을 붙이는 것이 좋습니다. 인스턴스 변수를 필요로 하지 않는 경우 static을 붙이면 메서드 호출 시간이 짧아지며 성능이 향상됩니다. static이 없는 메서드(인스턴스 메서드)는 실행 시 호출되어야 할 메서드를 찾는 과정이 추가로 필요하기 때문에 시간이 더 걸립니다.

요약하면, static 키워드는 클래스 설계 시 모든 인스턴스에서 공통으로 사용하는 변수를 선언할 때, 인스턴스 변수를 사용할 수 없는 클래스 메서드를 정의할 때, 인스턴스 변수를 사용하지 않는 메서드를 고려할 때 사용됩니다.

- 인스턴스 메서드: 객체가 생성될 때 메모리에 할당되며, 객체를 통해서만 호출할 수 있는 메서드입니다. 인스턴스 메서드 내에서는 모든 멤버(인스턴스 변수, 인스턴스 메서드, static 변수, static 메서드)를 호출할 수 있습니다.
인스턴스 메서드:

인스턴스 메서드는 객체의 인스턴스를 생성한 후에 호출할 수 있는 메서드입니다.
인스턴스 메서드는 객체의 상태를 변경하거나, 객체의 동작을 수행하는 데 사용됩니다.
인스턴스 메서드 내에서는 인스턴스 변수와 다른 인스턴스 메서드에 접근할 수 있습니다.

```java
public class Test {
    void instanceMethod() {
        System.out.println("This is an instance method.");
    }
}

Test t = new Test();
t.instanceMethod(); // 객체를 통해 메서드 호출
```
- 따라서, static 메서드는 클래스에 종속되어 있고 인스턴스와는 관련이 없는 독립적인 메서드입니다. 반면에 인스턴스 메서드는 객체의 인스턴스와 관련된 작업을 수행하는 메서드입니다.

## 오버로딩(overloading)
- 같은 이름의 메서드를 여러 개 정의하는 것을 메서드 오버로딩이라고 합니다. 매개변수의 타입이나 개수가 다르면 같은 이름의 메서드를 여러 개 만들 수 있습니다.
- 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 '메서드 오버로딩 (method overloading)'이라고 합니다. 메서드 오버로딩은 같은 이름의 메서드를 정의한다고 해서 무조건적으로 오버로딩이 되는 것은 아닙니다. 메서드 오버로딩이 성립하기 위해서는 다음과 같은 조건을 만족해야 합니다:

1. 메서드 이름은 동일해야 합니다.
2. 매개변수의 개수가 다르거나, 매개변수의 타입이 다르거나, 또는 매개변수의 순서가 다르거나 해야 합니다. 즉, 매개변수의 시그니처가 달라야 합니다.
3. 메서드의 반환 타입은 오버로딩을 결정하는 요소가 아닙니다. 반환 타입은 동일하거나 다를 수 있습니다.
4. 메서드의 접근 제어자나 예외 처리에 영향을 주지 않습니다. 오버로딩은 매개변수의 시그니처에 따라 결정됩니다.

위의 조건을 충족하는 경우, 같은 이름의 메서드를 여러 개 정의하여 다양한 매개변수 조합에 대해 동일한 메서드 이름으로 호출할 수 있습니다. 이를 통해 코드의 가독성을 높이고, 유사한 작업을 수행하는 메서드들을 한 곳에서 관리할 수 있습니다.
```java
void println() { ... }
void println(String str) { ... }
void println(int num) { ... }
```
- 오버로딩이 아닌 경우 예시
- 매개변수의 이름만 다를 뿐 매개변수의 타입이 같은 경우
```java
int add(int a, int b) { return a+b; }
int add(int x, int y) { return x+y; }
```
- 리턴타입만 다른 경우
```java
int add(int a, int b) { return a+b; }
long add(int a, int b) { return (long)(a+b); }
```

- 오버로딩인 경우 예시
- 모두 int형과 long형 매개변수가 하나씩 선언되어 있지만, 서로 순서가 다른 경우
```java
long add(int a, long b) { return a+b; } 
long add(long a, int b) { return a+b; }
```

###상속

객체 지향 프로그래밍에서 상속은 한 클래스의 속성과 메서드를 다른 클래스가 받아들이는 메커니즘입니다. 이를 통해 코드의 재사용성을 높일 수 있고, 기존 클래스를 수정하지 않고도 기능을 확장하거나 변경할 수 있습니다.

```java
class 부모클래스 {
    // 코드
}

class 자식클래스 extends 부모클래스 {
    // 코드
}
```

- 상속은 클래스 간의 계층적인 관계를 맺어줍니다. 부모 클래스(상위 클래스 또는 슈퍼 클래스)의 특성과 동작을 하위 클래스(자식 클래스 또는 서브 클래스)가 물려받아 사용할 수 있게 됩니다. 이로 인해 코드의 재사용성과 확장성이 증가하며, 클래스 간의 관계를 더욱 명확하게 표현할 수 있습니다.

- 오버라이드는 상속 관계에서 자식 클래스가 부모 클래스의 메서드를 재정의하는 것을 의미합니다. 부모 클래스에 이미 정의된 메서드를 자식 클래스에서 동일한 시그니처로 다시 구현함으로써, 자식 클래스에서 원하는 동작을 추가하거나 변경할 수 있습니다. 오버라이드된 메서드는 동적 바인딩을 통해 호출될 때, 객체의 실제 타입에 따라 실행됩니다. 이를 통해 다형성의 개념을 구현할 수 있습니다.

## 생성자(constructor)
- 객체가 생성될 때 자동으로 호출되는 메서드(인스턴스 초기화 메서드)로, 객체 초기화에 주로 사용합니다. 생성자의 이름은 클래스 이름과 동일해야 하며, 리턴 값이 없습니다.
(인스턴스 초기화란, 인스턴스변수들을 초기화하는 것을 뜻한다.)
```java
public class Test {
    Test() {
        System.out.println("객체가 생성되었습니다.");
    }
}

Test t = new Test(); // "객체가 생성되었습니다." 출력
```


다음은 생성자의 정의 형식입니다. 생성자는 오버로딩도 가능하므로 하나의 클래스에 여러 개의 생성자가 존재할 수 있습니다.

클래스이름(타입 변수명, 타입 변수명, ...) {
    // 인스턴스 생성 시 수행될 코드
    // 주로 인스턴스 변수의 초기화 코드를 작성합니다.
}

### 기본생성자
기본 생성자는 매개변수를 가지지 않고, 클래스에 명시적으로 정의되지 않은 경우에 자동으로 생성되는 생성자를 말합니다. 

기본 생성자는 클래스의 이름과 동일하며, 아무런 매개변수를 가지지 않습니다. 주로 인스턴스의 초기화 작업을 수행하거나, 다른 생성자를 호출하는 역할을 합니다. 

만약 클래스에 생성자가 명시적으로 정의되어 있지 않고, 기본 생성자도 정의되어 있지 않은 경우에는 컴파일러가 자동으로 기본 생성자를 생성합니다. 

기본 생성자의 정의 형식은 다음과 같습니다:

```java
public class ClassName {
    // 기본 생성자
    public ClassName() {
        // 인스턴스 초기화 작업 또는 다른 생성자 호출 등
    }
}
```

주의할 점은, 클래스에 다른 생성자가 이미 정의되어 있는 경우에는 기본 생성자가 자동으로 생성되지 않습니다. 따라서, 명시적으로 기본 생성자를 정의해야 합니다.

### 매개변수가 있는 생성자
매개변수가 있는 생성자는 인스턴스를 생성할 때 매개변수를 받아와서 초기화하는 생성자를 말합니다. 매개변수를 통해 인스턴스 변수의 초기값을 설정할 수 있습니다.

매개변수가 있는 생성자는 클래스 내에 명시적으로 정의되며, 인스턴스 생성 시에 호출될 때 매개변수로 전달된 값을 받아와서 인스턴스 변수를 초기화합니다. 이를 통해 인스턴스를 생성할 때 다양한 값을 전달할 수 있습니다.

매개변수가 있는 생성자의 정의 형식은 다음과 같습니다:

```java
public class ClassName {
    // 매개변수가 있는 생성자
    public ClassName(매개변수 타입 매개변수명, ...) {
        // 인스턴스 변수 초기화 또는 다른 초기화 작업
    }
}
```

위의 형식에서 `매개변수 타입`과 `매개변수명`은 각각 해당 매개변수의 데이터 타입과 이름을 나타냅니다. 생성자 내에서는 전달받은 매개변수를 활용하여 인스턴스 변수를 초기화하거나 다른 초기화 작업을 수행할 수 있습니다.

매개변수가 있는 생성자를 정의하면 인스턴스를 생성할 때 해당 생성자를 호출하여 매개변수를 전달해야 합니다. 이를 통해 다양한 값을 가진 객체를 생성할 수 있습니다.

### 생성자에서 다른 생성자 호출하기 - this()
생성자에서 다른 생성자를 호출하는 것을 "this"를 사용하여 구현할 수 있습니다. "this" 키워드를 사용하여 같은 클래스 내의 다른 생성자를 호출할 수 있습니다. 이를 통해 중복되는 초기화 코드를 피하고, 코드 재사용성을 높일 수 있습니다.

생성자에서 다른 생성자를 호출하는 방법은 다음과 같습니다:

1. 생성자 내에서 "this" 키워드를 사용하여 다른 생성자를 호출합니다.
2. 호출할 생성자의 매개변수를 지정하여 호출합니다.
3. 생성자 호출은 첫 번째 문장으로 수행되어야 합니다.

아래는 생성자에서 다른 생성자를 호출하는 예시입니다:

```java
public class ClassName {
    private int number;
    private String name;

    // 매개변수가 있는 생성자
    public ClassName(int number, String name) {
        this.number = number;
        this.name = name;
    }

    // 매개변수가 없는 생성자 (다른 생성자 호출)
    public ClassName() {
        this(0, "Default");
    }
}
```

위의 예시에서 `ClassName(int number, String name)` 생성자는 매개변수를 받아와서 인스턴스 변수를 초기화합니다. `ClassName()` 생성자는 매개변수가 없지만, "this"를 사용하여 `ClassName(int number, String name)` 생성자를 호출합니다. 이를 통해 기본 값을 갖는 객체를 생성할 때 중복 코드를 피하고, 매개변수가 있는 생성자를 호출하여 초기화 작업을 수행합니다.

"this" 키워드를 사용하여 생성자를 호출할 때 주의할 점은 생성자 호출은 첫 번째 문장으로 수행되어야 한다는 것입니다. 이유는 생성자 호출 후에 다른 코드를 실행하면 호출한 생성자가 이미 초기화 작업을 완료한 상태에서 다른 코드가 실행되기 때문입니다.

"this" 키워드를 사용하여 생성자를 호출함으로써 코드의 재사용성을 높이고, 초기화 작업을 효율적으로 처리할 수 있습니다.

## 변수의 초기화
- 변수를 선언하면서 동시에 처음으로 값을 저장하는 행위를 변수의 초기화라고 합니다. 모든 변수는 사용 전에 반드시 초기화되어야 합니다.

변수의 초기화는 변수에 값을 할당하는 과정을 의미합니다. 변수를 사용하기 전에 초기값을 설정하여 변수를 유효한 상태로 만들어야 합니다.

변수의 초기화는 다음과 같은 방법으로 수행할 수 있습니다:

1. 선언과 동시에 초기화: 변수를 선언할 때 값을 할당하는 방법입니다.
```java
int number = 10;
String name = "John";
```

2. 생성자를 이용한 초기화: 생성자를 사용하여 변수를 초기화하는 방법입니다.
```java
public class MyClass {
    private int number;
    private String name;
    
    public MyClass(int number, String name) {
        this.number = number;
        this.name = name;
    }
}
```

3. 메서드를 이용한 초기화: 메서드를 호출하여 변수를 초기화하는 방법입니다.
```java
public class MyClass {
    private int number;
    private String name;
    
    public void initialize(int number, String name) {
        this.number = number;
        this.name = name;
    }
}
```

4. 초기화 블록을 이용한 초기화: 클래스 초기화 블록 또는 인스턴스 초기화 블록을 사용하여 변수를 초기화하는 방법입니다.
```java
public class MyClass {
    private int number;
    private String name;
    
    // 클래스 초기화 블록
    static {
        number = 10;
        name = "John";
    }
    
    // 인스턴스 초기화 블록
    {
        number = 20;
        name = "Jane";
    }
}
```

변수의 초기화는 변수를 사용하기 전에 해당 변수에 유효한 값을 할당하는 것이 중요합니다. 초기화하지 않은 변수를 사용하면 컴파일 오류 또는 런타임 오류가 발생할 수 있습니다. 따라서 변수를 정의하고 사용하기 전에 적절한 초기화를 수행해야 합니다.

### 멤버변수의 초기화
멤버 변수의 초기화는 클래스의 멤버 변수에 값을 할당하는 과정을 말합니다. 멤버 변수는 클래스 내에서 선언된 변수로, 인스턴스 변수와 클래스 변수로 나뉩니다. 멤버 변수의 초기화는 클래스의 객체가 생성될 때 해당 변수에 초기값을 설정하는 것을 의미합니다.

멤버 변수의 초기화는 다음과 같은 방법으로 수행할 수 있습니다:

1. 선언과 동시에 초기화: 멤버 변수를 선언할 때 값을 할당하는 방법입니다.
```java
public class MyClass {
    private int number = 10;
    private String name = "John";
}
```

2. 생성자를 이용한 초기화: 생성자를 사용하여 멤버 변수를 초기화하는 방법입니다.
```java
public class MyClass {
    private int number;
    private String name;
    
    public MyClass(int number, String name) {
        this.number = number;
        this.name = name;
    }
}
```

3. 인스턴스 초기화 블록을 이용한 초기화: 인스턴스 초기화 블록을 사용하여 멤버 변수를 초기화하는 방법입니다.
```java
public class MyClass {
    private int number;
    private String name;
    
    // 인스턴스 초기화 블록
    {
        number = 10;
        name = "John";
    }
}
```

멤버 변수의 초기화는 해당 변수가 속한 클래스의 객체가 생성될 때 수행됩니다. 초기화되지 않은 멤버 변수는 해당 변수의 타입에 따라 기본값으로 초기화됩니다. 기본값은 정수형 변수는 0, 실수형 변수는 0.0, boolean 변수는 false, 참조형 변수는 null입니다.

멤버 변수의 초기화는 해당 변수를 사용하기 전에 값을 할당하여 올바른 동작을 보장하기 위해 중요합니다. 초기화되지 않은 변수를 사용하면 예상치 못한 동작이 발생할 수 있으므로 항상 초기화에 주의해야 합니다.

참고 자료)  

[1]: https://velog.io/@jeong11/Java-OOP-callstack
