# 객체지향 프로그래밍 II

1. [패키지](#패키지)
    1. [패키지선언](#패키지선언)
    2. [클래스패스](#클래스패스)
    3. [import문](#import문)
2. [캡슐화와접근제어자](#캡슐화와접근제어자)
    1. [캡슐화](#캡슐화)
    2. [접근제어자](#접근제어자)
3. [상속](#상속)

## 페키지
패키지는 클래스와 인터페이스를 포함하는 이름이 붙은 단위입니다. 이는 물리적으로 클래스와 인터페이스를 담고 있는 디렉토리를 의미하기도 합니다. 패키지는 클래스를 구조적으로 잘 정리하고, 클래스의 이름 충돌을 방지하며, 코드의 재사용을 가능하게 합니다.

![Alt Text](https://blog.kakaocdn.net/dn/HNKp4/btqTSTOhd5w/czMDHudypbKmPxdoADsnLK/img.png)

패키지를 통해서 라이브러리끼리 구분이 가능합니다.

패키지를 사용하는 이유는 클래스명의 고유성을 보장하기 위함입니다.
- 클래스 이름이 같더라도 다른 패키지의 클래스라면 문제가 발생하지 않습니다.
- 패키지 내부에는 서브 패키지도 있을 수 있어서 점(.)을 통해서 구분합니다. ex) java.lang.String : java.lang 패키지 내부의 String 클래스
- 해당 클래스만 쓰고 싶다면 import Human.클래스명 처럼 작성하면 됩니다. 패키지 내 모든 클래스를 사용하고 싶다면 import Human.* 을 입력하면 됩니다.




### 페키지선언
패키지를 선언하려면 클래스의 맨 위에 package 키워드를 사용하고 패키지의 이름을 명시하면 됩니다. 예를 들어, com.example라는 이름의 패키지를 선언하려면 다음과 같이 작성합니다.

```java
package 패키지명;
```
- 모든 클래스는 반드시 하나의 패키지에 포함되어야 한다고 했다. 그럼에도 불구하고 지금까 지 소스파일을 작성할 때 패키지를 선언하지 않고도 아무런 문제가 없었던 이유는 자바에서 기본적으로 제공하는 '이름 없는 패키지(unnamed package), 때문입니다.

### 클래스패스

- 클래스패스는 JVM(Java Virtual Machine)이나 Java 툴이 사용자 클래스 파일의 위치를 찾는데 사용하는 환경 변수입니다.
- JVM이 프로그램 실행할 때, 클래스 파일을 찾기 위한 경로를 뜻하게 된다.

- 클래스 패스를 설정하기 위한 방법은 두 가지로 java runtime에 -classpath 옵션을 추가하거나 CLASSPATH 환경변수를 추가하는 방법입니다.

- ';'를 구분자로 하여 여러 개의 경로를 클래스패스에 지정할 수 있으며, 맨 앞에 추가한 이유는 현재 디렉토리(.)를 클래스패스에 포함시키기 위해서입니다.

 -classpath 예제

 ```java
 class Exam1{
    void print(){
        System.out.println("Exam1");
    }
}

class Exam2{
    void print(){
        System.out.println("Exam2");
    }
}


public class ClassPathEx {
    public static void main(String[] args) {
        Exam1 ex1 = new Exam1();
        Exam2 ex2 = new Exam2();

        ex1.print();
        ex2.print();
    }
}
```
- 다음 코드를 작성하고 javac ClaaPathEx.java 명령어를 입력
- 컴파일을 실행하면 각 클래스마다 클래스 파일(.class)을 생성하게 됩니다.
- 이후 Exam1.class와 Exam2.class 파일들을 새로운 폴더(dir)를 생성하여 이동시킵니다.
- ClassPathEx.class 파일을 실행시키기 되면 Exam1.class, Exam2.class 파일을 찾지 못하는 오류가 발생합니다.

오류 발생 상황 -classpath로 해결

![Alt Text](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FyRexu%2FbtqTPyKR2bL%2FlULu7KZiCmo0jFl1PWK4rK%2Fimg.png)
- -classpath 옵션을 이용하여 클래스 파일이 있는 경로를 지정하면 java runtime이 지정된 경로에서 클래스 파일을 찾게 됩니다.

- java -classpath ".:경로" 클래스파일명을 입력하면 클래스파일이 있는 경로를 지정한 후 실행하게 되는 것입니다. 올바른 출력이 나타나는 것을 확인할 수 있습니다.
Unix계열에서는 java -classpath ".:경로" 클래스파일명, 윈도우에서는 java -classpath ".;경로" 클래스파일명 입니다.



### import문

소스코드 작성 시 다른 패키지 안에 들어있는 클래스를 사용 시에 패키지 경로까지 추가하여 클래스를 사용해야 합니다.

하지만, 하나의 클래스가 이름이 길어지면 비효율적이므로 자바에서 import 키워드를 제공하고 있습니다.

import문 역할은 컴파일러에게 소스코드에 사용된 클래스의 패키지에 대한 정보를 제공하여 패키지 경로를 제외하고 클래스 이름만 사용할 수 있습니다.

## 캡슐화와 접근제어자

### 캡슐화

캡슐화는 객체의 속성(데이터 필드)와 메소드를 하나로 묶는 과정을 말합니다. 이를 통해 객체의 상태를 외부에서 직접 변경하지 못하게 하며, 오직 정의된 메소드를 통해서만 상태를 변경할 수 있게 됩니다. 이러한 캡슐화는 클래스의 상태를 보호하고, 외부로부터의 직접적인 접근을 제한하는 중요한 원칙입니다.
![Alt Text](https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EC%BA%A1%EC%8A%90%ED%99%94.png?resize=750%2C377&ssl=1)

### 접근제어자

- 접근제어자를 통해 클래스 내부의 데이터와 메소드에 대한 접근을 제한하고, 외부에서의 불필요한 접근을 차단하여 코드의 안정성을 보장할 수 있습니다. 예를 들어, private 접근제어자를 사용하면 해당 클래스 내부에서만 해당 데이터에 접근하거나 메소드를 호출할 수 있으므로 데이터의 변조를 막을 수 있습니다.

자바에서는 4가지 접근제어자를 제공하며, 이를 통해 클래스 멤버의 접근 수준을 제어합니다.

- private: 멤버는 같은 클래스 내에서만 접근 가능하다.
- default (접근제어자를 지정하지 않는 경우): 멤버는 같은 패키지 내의 다른 클래스에서 접근 가능하다.
- protected: 멤버는 같은 패키지 내의 다른 클래스 또는 다른 패키지의 서브 클래스에서 접근 가능하다.
- public: 모든 곳에서 접근 가능하다.
-접근제어자를 통해 클래스 내부의 데이터와 메소드에 대한 접근을 제한하고, 외부에서의 불필요한 접근을 차단하여 코드의 안정성을 보장할 수 있습니다. 예를 들어, private 접근제어자를 사용하면 해당 클래스 내부에서만 해당 데이터에 접근하거나 메소드를 호출할 수 있으므로 데이터의 변조를 막을 수 있습니다.

![ALt Text](https://blog.kakaocdn.net/dn/d6uXel/btqT01FoQiN/QkaG2tkLZL7QHtvuCccrIK/img.png)
- 접근 범위가 넓은 쪽에서 좁은 쪽의 순으로 왼쪽부터 나열하면 다음과 같다.
접근제한없음 같은패키지+자손 같은패키지 같은클래스 public〉protected〉(default) 〉private


접근제어자는 클래스, 인터페이스, 멤버 변수, 메소드에 모두 사용될 수 있습니다. 자바에서는 클래스 또는 인터페이스의 접근제어자로 public 또는 default만을 허용합니다. 또한, 클래스 내부의 멤버 변수나 메소드는 모든 접근제어자를 사용할 수 있습니다.

``` java

public class Test {
    private int privateVar = 1;
    int defaultVar = 2; // default 접근제어자는 키워드를 생략합니다.
    protected int protectedVar = 3;
    public int publicVar = 4;

    // 메소드에도 동일하게 적용됩니다.
    private void privateMethod() {}
    void defaultMethod() {}
    protected void protectedMethod() {}
    public void publicMethod() {}
}
```
이렇게 캡슐화와 접근제어자를 통해 클래스의 내부 구현을 적절히 보호하고 외부로부터의 접근을 제한함으로써 소프트웨어의 안정성과 유지보수성을 향상시킬 수 있습니다.


### 상속

객체 지향 프로그래밍에서 상속은 한 클래스의 속성과 메서드를 다른 클래스가 받아들이는 메커니즘입니다. 이를 통해 코드의 재사용성을 높일 수 있고, 기존 클래스를 수정하지 않고도 기능을 확장하거나 변경할 수 있습니다.

```java
class 부모클래스 {
    // 코드
}

class 자식클래스 extends 부모클래스 {
    // 코드
}
```

- 상속은 클래스 간의 계층적인 관계를 맺어줍니다. 부모 클래스(상위 클래스 또는 슈퍼 클래스)의 특성과 동작을 하위 클래스(자식 클래스 또는 서브 클래스)가 물려받아 사용할 수 있게 됩니다. 이로 인해 코드의 재사용성과 확장성이 증가하며, 클래스 간의 관계를 더욱 명확하게 표현할 수 있습니다.

- 오버라이드는 상속 관계에서 자식 클래스가 부모 클래스의 메서드를 재정의하는 것을 의미합니다. 부모 클래스에 이미 정의된 메서드를 자식 클래스에서 동일한 시그니처로 다시 구현함으로써, 자식 클래스에서 원하는 동작을 추가하거나 변경할 수 있습니다. 오버라이드된 메서드는 동적 바인딩을 통해 호출될 때, 객체의 실제 타입에 따라 실행됩니다. 이를 통해 다형성의 개념을 구현할 수 있습니다.



[ 참고자료 ]

패키지: https://math-coding.tistory.com/168
