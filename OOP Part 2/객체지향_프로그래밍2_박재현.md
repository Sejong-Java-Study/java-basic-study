# 객체지향 프로그래밍 II

## Chapter 7 (01 ~ 52)
 
1. [상속](#상속)
    1. 단일 상속
    2. 모든 클래스의 조상 Obejct
    3. 클래스 간 관계
    4. 다형성
        1. [매개변수의 다형성](#매개변수의-다형성)
        2. [객체배열의 다형성](#객체배열의-다형성)
2. [오버라이딩](#오버라이딩)
3. [패키지(package)](#패키지(package))
    1. 클래스패스(classpath)
    2. import
    3. staic import
4. [제어자](#제어자)
    1. 접근제어자
        1. 캡슐화
    2. static, final, abstract
5. [super](#super)
6. [동적관리배열 (Vector)](#동적관리배열-vector)
7. [추상 클래스](#추상-클래스)
    1. [추상클래스 특징](#추상클래스-특징)
    2. [추상메서드](#추상메서드)
8. [인터페이스](#인터페이스)
    1. [제약사항](#제약사항)
    2. [인터페이스의 상속과 구현](#인터페이스의-상속과-구현)
    3. [인터페이스를 통한 다형성](#인터페이스를-통한-다형성)
    4. [인터페이스의 장점](#인터페이스의-장점)
    5. [default 메서드와 static 메서드](#default-메서드와-static-메서드)
9. [내부 클래스](#내부-클래스)
    1. [내부클래스의 종류와 특징](#내부클래스의-종류와-특징)
    2. [내부클래스의 주의점](#내부클래스의-주의점)
10. [익명 클래스](#익명-클래스)
11. [문제풀이](#문제풀이)

## 상속
- 객체지향 언어의 기본적인 특징으로 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.
- 기존의 방대한 양의 코드를 상속을 사용하여 적은 양으로 작성할 수 있다.
- 이러한 특징은 ***코드의 재사용성***을 높이고 ***코드의 중복을 제거***하여 프로그램의 생산성과 유지보스에 크게 기여한다.

### 매개변수의 다형성
- 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.

### 객체배열의 다형성
- 조상타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다.
- 묶어서 다루고 싶은 객체들의 상속관계를 따져 가장 가까운 공통조상 클래스타입의 참조변수 배열을 생성하면 된다.

```java
class Product { }
class TV extends Product { }
class Audio extends Product { }
class Laptop extends Product { }

public class Example {
    public static void main(String[] args) {
        Product p[] = new Product[3];
        p[0] = new TV();
        p[1] = new Audio();
        p[2] = new Laptop();
    }
}
```

참고 자료
- [상속(inheritance)](https://develaniper-devpage.tistory.com/75)

## 오버라이딩
- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다.
- 그대로 사용해도 되지만 자손 클래스에 맞게 변경해서 사용하는 경우가 많다.

```java
class Human {
    void Walk() {
        System.out.println("Human is walking.");
    }
}

class Andrew extends Human {
    @override
    void Walk()
    {
        System.out.println("Fxxk Up! Andrew doesn't walk.");

        System.out.println("Andrew always running regardless how much painful he is.");
    }
}
```
[Top-G](https://make-spend-money.tistory.com/209)

## 패키지
- 클래스의 묶음으로 클래스 또는 인터페이스를 포함 시킬 수 있다.
- 관련된 클래스들끼리 그룹으로 묶어 놓음으로써 클래스 관리에 더욱 효율적이다.
- 패키지 체계를 유지함으로써 외부 라이브러리의 클래스명과 충돌되는 것을 방지할 수 있다. 사실 클래스의 풀네임은 ***패키지명을 포함***한 것이라 가능한 것이다.
- 쉽게 폴더개념으로 이해하면 된다. 실제로 물리적으로 클래스는 하나의 클래스파일, 페키지는 하나의 폴더이다.
- 패키지의 선언은 다음과 같다.

```java
package 패키지명;
package com.example.sju.standard;
```

## 제어자
- 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 크게 접근 제어자와 그 외 제어자(static, final, abstract 등)로 나눌 수 있다.

    1. final
        - '변경될 수 없는'의 의미를 가지고 있으며 거의 모든 대상에 사용될 수 있다.
        - 그 의미처럼 변수에 사용되면 값을 변경할 수 없는 상수가 되고 메서드에 사용되면 오버라이딩을 할 수 없게 되고 클래스에 사용되면 자손 클래스를 정의하지 못하게 된다.

    2. abstract
        - '미완성'의 의미를 가지고 있다.
        - 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않는 ***추상 메서드***를 선언하는데 사용한다.

    3. 접근 제어자
        - 이 또한 객체지향에서 보이는 주요한 특징 중 하나인 캡슐화와 직결된 내용이다.
        - 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.
        - 접근 제어자의 종류로는 다음과 같다. ```private, default, protected, public```
        - private는 같은 클래스 내에서만 접근 가능하다.
        - default는 갘은 패키지 내에서만 접근이 가능하다.
        - protected는 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
        - public은 접근 제한이 전혀 없다.
        - default 같은 경우 기본으로 적용되는 범위이기에 실제로 붙이지 않아도 default로 인식한다.

## super
- this처럼 super도 참조자이다.
- this는 자기 자신을 참조하는 데에 반해, super는 조상 클래스를 참조한다. 따라서 this()처럼 자기 자신의 생성자를 부르듯이 super()로 조상의 생성자도 부를 수 있다.

```java
class Human {
    int height;
    float weight;
    boolean gender;

    Human(int height, float weight, boolean gender) {
        this.height = height;
        this.weight = weight;
        this.gender = gender;
    }
}

class Andrew extends Human {
    int GaO;

    Andrew(int height, float weight, int GaO) {
        super(height, weight, 1);

        this.GaO = GaO;
    }
}
```

## 동적관리배열 (Vector)
- 배열은 같은 종류의 여러 데이터를 다루는 데에 편리한 자료구조이지만, 데이터의 크기를 예측할 수 없어 불편함을 갖는다.   
이런 단점을 해결하기 위해 Java에서는 Vector 클래스를 제공한다.
- Vector 클랫는 데이터를 가변크기로 설정할 수 있고, 요소의 개수에 따라 자동으로 크기를 조절한다.
- 관련된 알면 좋은 지식으로 ***Wrapper 클래스***와 ***Generic***이 있다.

### Vector 클래스의 특징
- java.util.List 인터페이스를 구현한 컬렉션이다.
- 객체의 삽입, 삭제, 이동이 쉽다.
- 데이터를 저장한 순서를 기억한다. (순서대로 저장)
- 데이터 중복 저장을 허용한다.
- 다양한 타입의 데이터들을 저장할 수 있다.
- 기본형 데이터는 저장할 수 없다.
(단, JDK 1.5부터 자동으로 Wrapper 클래스 유형으로 바뀌며 저장할 수 있다.)

## 추상 클래스
- 클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도에 비유할 수 있다.
- 클래스에서의 미완성이라 함은 멤버의 개수가 아닌 메서드의 미완성(추상메서드)을 의미한다.
- 미완성인 만큼 추상클래스로 인스턴스를 만들 수 없고 ***상속***을 통해 자손클래스에 의해서만 가능하다.

### 추상클래스 특징
- 미완성 설계도, 인스턴스 생성 불가
- 미완성 메서드(추상메서드)를 포함하고 있는 클래스

### 추상메서드
- 메서드는 선언부와 구현부로 구성되어 있는데 여기서 선언부만 작성하고 구현부를 작성하지 않은 것이 추상메서드이다.
- 이와 같이 미완성 상태로 남겨 놓는 이유는 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문이다. 그래서 추상클래스를 상속받는 자손클래스는 조상의 추상메서드를 상황에 맞게 적절히 구현해주어야 한다.
- 추상메서드에는 키워드```abstract```를 앞에 붙여주고, 구현부가 없기 때문에 ```{ }``` 대신 ```;```을 적어준다.

## 인터페이스
- 일종의 추상클래스이나 높은 추상화로 인한 어떠한 일반 메서드와 멤버 변수를 가질 수 없고 오직 추상메서드와 상수만을 멤버로 가질 수 있다. (예외 존재 - 후술)
- 인터페이스도 추상클래스처럼 완성되지 않은 불완전한 것이기 때문에 그 자체만으로 사용되기 보다는 다른 클래스를 작성하는데 도움을 줄 목적으로 작성된다.
- 비유하자면 추상클래스는 마치 ***건담의 뼈대***, 기본클래스는 ***건담의 뼈대에 붙는 몸체***, 인터페이스는 몸체에 장착할 수 있는 ***부가적인 파츠들***이다.   
(물론 실체화, 인스턴스화는 다른 얘기이다.)
- 인터페이스를 작성하는 것은 클래스를 작성하는 것과 같다.   
다만 키워드로 class 대신 interface를 사용한다는 것만 다르다. 그리고 interface에도 클래스처럼 접근제어자로 public 또는 default만 사용할 수 있다.

```java
interface Flyable {
    public static final FLYING = 1;
    public static final NOT_FLYING = 0;
    public abstract OnFly(Vector3 acc);
}
```

### 제약사항
- 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
- 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.   
단, static 메서드와 default 메서드는 예외(JDK 1.8부터)
- 예외없이 공통으로 적용되기에 제어자 생략이 가능하며, 편의상 생략하는 경우가 많다.   
생략된 제어자는 컴파일 시, 컴파일러가 자동으로 추가해준다.

### 인터페이스의 상속과 구현
- 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속을 받는 것이 가능하다.
- 인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며, 상속을 통해 추상클래스의 추상메서드가 완성되는 것처럼, 인터페이스도 자신에게 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 한다.
- 인터페이스는 클래스를 확장한다는 의미의 키워드 ```extends```를 사용하지 않고 구현한다는 의미의 키워드 ```implements```를 사용한다.


```java
interface Movable {
    void Move(int x, int y);
}

interface Attackable {
    void Attack(Object obj, int damage);
}

interface Untargetable {
    void ItsGwenTime();
}

interface GwenIsUntargetable extends Movable, Attackable, Untargetable { }

class Gwen extends Champion implements GwenIsUntargetable { }
```

### 인터페이스를 통한 다형성
- 인터페이스 역시 이를 구현한 클래스의 조상이라 할 수 있으므로 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며 형변한 또한 가능하다.
- 인터페이스는 메서드의 매개변수의 타입으로도 사용될 수 있고 이에 대한 의미는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야 한다는 것이다.
- ***반환 타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.***

```java
class Fighter extends Unit implements Fightable {
    public void Move(int x, int y);
    public void Attack(Fightable f);
}
```

### 인터페이스의 장점
- 개발시간을 단축시킬 수 있다.
- 표준화가 가능하다.
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
- ***독립적인 프로그래밍이 가능하다.***

### default 메서드와 static 메서드
- 본래 인터페이스에는 추상메서드만 선언할 수 있으나 JDK 1.8부터 default 메서드와 static 메서드도 추가할 수 있게 되었다.
- static 메서드는 인스턴스와 관계없는 독립적인 메서드이기 때문에 추가되었다.
- default 메서드의 경우는 모든 클래스들이 새로 추가된 메서드를 구현해야 하는 수고를 덜기 위해 그럴 필요가 없는 메서드를 구분하고자 추가할 수 있게 되었다.   
따라서 추상메서드와 달리 몸통 ```{ }```이 있어야 한다.

## 내부 클래스
- 클래스 내부에서 클래스를 선언할 수 있는데 이를 내부 클래스라고 한다.
- 클래스가 오직 클래스 내부에서만 쓰인다면 주로 내부 클래스로 선언한다.   
(이런 경우 두 클래스가 긴밀한 관계에 있다고 한다.)
- 내부클래스는 클래스 내부에서 선언한다는 점을 제외하고는 다른 클래스와 크게 다르지 않다.

### 내부클래스의 종류와 특징
- 내부클래스에서 외부클래스의 멤버들을 쉽게 접근할 수 있다.   
(내부와 외부 클래스에 선언된 변수이름이 동일하면 ```외부클래스명.this```를 붙여 구별할 수 있다.)
- 코드의 복잡성을 줄일 수 있다. (캡슐화)
- 내부클래스도 abstract, final 같은 제어자를 사용할 수 있고 private, protected와 같은 접근 제어자도 사용 가능하다.
- 변수가 선언된 위치에 따라 인스턴스, 클래스, 스태틱, 지역 변수로 나뉘듯이 내부클래스도 이와 마찬가지로 나뉜다. 그리고, 각 위치에 따라 같은 선언위치의 변수와 동일한 유효범위(scope)와 접근성(accessibility)을 갖는다.

|<div style="width: 140px">내부클래스</div>|특징|
|---------------------------------------|---|
|인스턴스 클래스<br>(instance class)|외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언된다.|
|스태틱 클래스<br>(static class)   |외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static 멤버처럼 다루어진다. 주로 외부 클래스의 static 멤버, 특히 static 메서드에서 사용될 목적으로 선언된다.|
|지역 클래스<br>(local class)     |외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.|
|익명 클래스<br>(anonymous class) |클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)|

```java
public class Example() {

    class MyRunnable implements Runnable{
        @Override
        public void run() {
            System.out.println("-- Runnable Run --");
        }
    }
}
```

### 내부클래스의 주의점
- 내부 클래스 중에서 스태틱 클래스(StaticInner)만 static 멤버를 가질 수 있다.
- 내부 클래스에서 static 변수를 선언해야 한다면 스태틱 클래스로 선언해야 한다.   
다만, final과 static이 동시에 붙은 변수는 상수(constant)이므로 모든 내부 클래스에서 정의가 가능하다.
- 스태틱 멤버는 객체생성 없이 접근 가능하고 인스턴스 멤버는 그렇지 않다. (메모리 로딩 여부)   
따라서 인스턴스 클래스는 스태틱 클래스의 멤버들을 접근 가능, 스태틱 클래스는 인스턴스 클래스의 멤버들 접근 불가능 하므로 유의하도록 하자.
- 지역 클래스는 외부 클래스의 인스턴스 멤버와 스태틱 멤버 모두 사용할 수 있으며, 지역 클래스가 포함도니 메서드에 정의도니 지역변수도 사용할 수 있다.   
단, final이 붙은 지역변수만 접근가능한데 이유는 지역변수가 소멸된 시점에도, 지역 클래스의 인스턴스가 소멸된 지역변수를 참조하려는 경우가 발생할 수 있기 때문이다.   
(JDK 1.8부터 지역 클래스에 접근하는 지역변수 앞에 final가 없어도 컴파일러가 자동으로 붙여주기 떄문에 생략할 수 있다.)

## 익명 클래스
- 다른 클래스들과 달리 이름이 없는 클래스
- 클래스의 선언과 객체 생성을 동시에 한다.
- 단 한 번의 사용, 오직 하나만의 객체를 만들 수 있는 일회용 클래스

### 익명클래스 주의점
- 이름이 없기 때문에 생성자를 가질 수 없고   
하나의 클래스를 상속 받거나 하나의 인터페이스만을 구현할 수 있다.

```java
Button btn = (Button) findViewById(R.id.btn);

btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // 동작
    }
});
```

## 참고자료
- [Android에서 OnClickListener 사용하기](#https://boheeee.tistory.com/23)
- [Java 내부클래스](#https://smoothiecoding.kr/자바-내부-클래스/)
- [알기쉬운 자바 Vector 클래스](#https://byungmin.tistory.com/9)
- [Wrapper 클래스](#http://www.tcpschool.com/java/java_api_wrapper)
- [제네릭이란?](#https://code-lab1.tistory.com/241)