# 객체지향 프로그래밍 II

1. [상속](#상속)
2. [오버라이딩](#오버라이딩)
3. [Super](#참조변수-super)
4. [제어자](#제어자)
   1. [static](#static)
   2. [final](#final)
   3. [abstract](#abstract)
5. [접근 제어자](#접근-제어자)
6. [캡슐화](#캡슐화)
7. [다형성](#다형성)
8. [참조변수 형변환](#참조변수의-형변환)
9. [매개변수의 다형성](#매개변수의-다형성)
10. [추상 클래스](#추상-클래스)
11. [인터페이스](#인터페이스)
12. [익명 클래스](#익명-클래스)

## 상속
프로그래밍에서의 상속은 extends, 확장한다는 의미이다. 상속을 사용하면 **코드를 재사용할 수 있고, 중복을 제거하여 생산성과 유지보수에 큰 기여를 한다.**
상속하는 클래스란 extends 대상인 상위 클래스를 뜻한다. 상속을 하게 되면, 상위 클래스의 멤버 변수를 그대로 갖고 있게 돼서, 상위 클래스보다 더 많은 멤버를 갖게 된다. (extends 의미)
하위 클래스의 인스턴스를 생성하면 상위 클래스 인스턴스를 생성하지 않고도 상속한 멤버들을 사용할 수 있다.

### (토의 주제) 하위 클래스 객체를 생성했을 때, 일어나는 JVM 메모리 변화 - 상위 클래스 객체를 생성하지 않고도 상위 클래스의 멤버를 사용할 수 있는 이유?

### 클래스 간의 관계 결정하기
클래스 들의 연관관계를 명확하게 함으로써 객체지향의 장점을 극대화해야 한다. 하나의 클래스에서 다른 클래스를 사용하는 경우
이는 **포함관계**로 코드를 재사용할 수 있다는 장점이 있다. 만약 포함이 아닌 상속을 사용한다고 해도 마찬가지로 코드의 재사용성이 높아진다.
하지만 포함관계와 상속관계는 의미가 다르다.
- 포함관계 : 두 클래스의 멤버는 서로 다른 영역이며, 공유될 수 없다.
- 상속관계 : 두 클래스의 멤버가 조상과 자손의 관계로, 조상의 멤버를 가진 상태로 확장될 수 있다.
클래스를 설계하면서 기존의 클래스 멤버를 가진 채 확장을 해야하는 클래스라면 **상속을 고려해볼 수 있다.**  
하지만 상속하지 않고도 다른 클래스를 사용할 수 있는 경우라면 **상속없이 포함관계로 설계할 수 있다.**(상속을 남용하지 않을 것)

### 단일 상속(Single Inheritance)
C++은 다중 상속이 가능하지만, 자바는 다중 상속이 불가능하다. 다중 상속이란 extends 대상이 두 개 이상인 경우이다.
다중 상속을 할 경우 여러 클래스들의 멤버를 가진 복합적인 클래스를 만들 수 있다는 장점이 있지만 그만큼 갖게 되는 멤버가
많아지기 때문에 클래스를 설계하는 과정에서 이름이 겹쳐서는 안된다. 또한 겹쳤을 경우, 이들을 구분하는 과정이 필요하다.
코드의 유지보수의 편의를 증대시키기 위한 자바의 선택은 단일 상속이다. **하나의 클래스만을 상속받게 되면 클래스 간 관계가
더욱 명확해지고, 코드를 더욱 신뢰할 수 있다는 장점이 있다.**

### 모든 클래스의 최상위 클래스 - Object
모든 클래스의 최상위 클래스는 Object이다. 따라서 모든 클래스가 toString(), equals() 같은 메서드를 바로 사용할 수 있는 것이다.
클래스가 상속한 대상이 없을 경우, 컴파일러가 자동으로 `extends Object`를 추가하여 Object로 상속받도록 한다.
> 만약 extends를 통해 상속한 대상이 있을 경우, 컴파일러가 `extends Object`를 추가하지는 않는다. (단일 상속 원칙)

## 오버라이딩
상속을 받게 되면 상위 클래스의 멤버 변수와 메서드를 그대로 물려 받는다. 이 때 상속받은 메서드의 이름과 반환타입, 매개변수를 그대로 유지한 채
구현부를 상황에 맞게 변경할 수 있다. 이를 재정의, Overriding이라고 한다. Override란 ~위에 덮어쓴다는 의미이다.

```java
class Point {
    int x;
    int y;

    String getLocation() {
        return "x :" + x + ", y :" + y;
    }
}

class Point3D extends Point {
    int z;

    @java.lang.Override
    String getLocation() {
        return "x :" + x + ", y :" + y + ", z :" + z;
    }
}
```
- Point3D 클래스는 Point 클래스를 상속받았기 때문에 Point 클래스의 멤버 변수와 메서드를 그대로 사용할 수 있을 것이라
  기대할 수 있다. 여기서 Override한 메서드를 사용할 때 예상할 수 있는 점은 **Point 클래스의 메서드의 특성과 연관관계가 있다는 것이다.**
  Point3D 클래스 내에 새롭게 메서드를 정의하는 것보다 코드에 의미를 부여하고, 클래스의 연관성을 잘 표현할 수 있다.

## 참조변수 super
클래스 내에서 자신의 멤버를 가리키는데 썼던 this와 마찬가지로 상속받은 멤버를 구분하는 데에 쓰이는 super라는 참조변수가 있다.
만약 상위클래스에 x라는 변수와 상속을 받은 하위클래스에서 x라는 변수가 있을 때, 상위 클래스의 x는 `super.s`, 하위 클래스의 x는 `this.s`로 구분된다.
또한 모든 인스턴스 메서드에는 this와 super가 지역변수로 존재한다. 여기에는 자신이 속한 인스턴스의 주소가 자동으로 저장된다.
**따라서 this와 super는 인스턴스의 주소를 가리키는 지역변수로 의미만 다를 뿐이다.**

## 생성자 super
가끔 어떠한 클래스를 들여다보게 되면 `super()`라는 생성자를 종종 보게 된다. 같은 클래스 내에서 다른 생성자(오버로딩)를 호출할 때 사용되었던 this()와 마찬가지로 super()는 상위 클래스의 생성자를 호출할 때 사용되는 코드이다.
super()가 많이 쓰이는 이유는 실제로 자바에 구현되어 있는 여러 클래스들이 서로 연관관계가 있는 것끼리 묶여있기 때문에 상속, 구현 등으로 이루어져 있다.
따라서 **클래스 내에서 직접 생성자를 만들기 보다 상위 클래스에 이미 구현되어 있는 생성자를 가져다 쓰는 경우가 많은 것이다.** `super()`
를 쓰게 되면 단순히 코드가 단순해지는 것을 넘어 클래스가 맡고 있는 멤버에 대해 책임을 지도록 할 수 있다.  
```java
  class Point {
    int x, y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
  }
  
  class Point3D extends Point {
    int z;
    
    // 하위 클래스에서 직접 상위 클래스 멤버를 초기화
    Point3D(int x, int y, int z){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    // super()를 사용함으로써 상위 클래스 멤버 초기화 작업을 직접 하지 않음.
    Point3D(int x, int y, int z){
        super(x,y); // 상속받은 멤버 x와 y는 super()를 사용함.
        this.z = z; // Point3D의 고유한 멤버인 z에 대한 초기화만을 직접 함.
    }
  }
```
- 상속받은 멤버에 대한 초기화 작업은 상위 클래스의 생성자를 이용하였다.(super()를 사용) 물론 하위 클래스에서 직접
  초기화할 수도 있지만, `super()`를 사용함으로써 상위 클래스의 멤버와 하위 클래스의 멤버를 구분할 수 있다. 위 코드에서
  `super()`를 사용하지 않은 생성자에서는 x,y,z 중 어느 것이 상위 클래스의 멤버인지 명확하게 보이지 않는다. 하지만
  `super()`를 사용한 **생성자의 경우 상위 클래스 멤버와 하위 클래스 멤버가 명확하게 코드로 확인이 된다. 이처럼 객체지향의 특성을
  사용하면 코드를 통해 역할과 의미를 한 눈에 이해할 수 있다는 장점이 있다.**

## 패키지
자바 혹은 스프링으로 작업을 하다보면 하나의 클래스만으로 기능을 구현하기란 쉽지 않다. 여러 클래스들이 독립적인 역할을
수행함과 동시에 비슷한 기능을 하는 클래스끼리 묶어주는 작업이 필요하다. 이렇게 디렉토리로 구분하게 되면 클래스를 보다
효율적으로 관리할 수 있다. 클래스의 묶음 단위를 **패키지**라고 한다.  
- 새롭게 알게된 점 : 클래스의 실제 이름에는 패키지 이름까지 포함된다. ex) String : java.lang.String  

따라서 같은 클래스 이름을 갖더라도 패키지가 다를 경우 다른 클래스로 구분이 된다는 것이다. 패키지는 물리적인 하나의 디렉토리이기 때문에
이 디렉토리(패키지)에 속한 클래스들의 이름에는 디렉토리(패키지) 이름이 포함되어야 한다.

### 클래스 소스파일 보는 법
교재에서는 rt.jar 파일을 통해 클래스 파일을 소개하고 있다. 교재는 자바 8버전이기 때문에 자바 11을 사용하는 경우 해당 파일이
안 보일 수 있다. 자바 11(JDK 11)의 경우, `Program Files/java/jdk-11/lib` 폴더 내에 있는 `src.zip` 파일을 통해 우리가 사용하는
자바 파일들을 확인할 수 있다. `java.base.java.lang` 폴더에 들어가면 String, StringBuffer 등의 파일들을 확인할 수 있다.  
![자바 소스 파일 사진](https://github.com/Sejong-Java-Study/java-basic-study/assets/70999462/9cdf26e7-f70a-4ded-b5f0-243a4aff471c)
> 사진에서도 알 수 있듯이 클래스 파일들이 전부 별도의 패키지(디렉토리) 안에 있는 것을 알 수 있다.

## 제어자
클래스의 멤버 변수 및 메서드에 제어자를 붙이는 경우가 많다. 제어자를 통해 데이터를 보호할 수 있으며, **객체지향의 핵심 중 하나인
캡슐화에도 큰 역할을 한다.**
### static
static은 `클래스의` 또는 `공통적인`의 의미를 갖고 있다. static이 붙은 변수 혹은 메서드는 인스턴스 생성과 상관없이
사용할 수 있기 때문에 인스턴스 멤버를 제어하지 않는 것이라면 static을 붙이는 것을 고려해볼 수 있다. 인스턴스를 생성하지
않고도 호출할 수 있기 때문에 편리하고 속도도 더 빠르다. static을 붙일지 안 붙일지 판단하는 기준은 **해당 인스턴스의 멤버
들을 사용하는 메서드 혹은 변수인지이다.** 앞으로 소스파일을 보면서 static이 붙은 멤버들을 볼 때마다 그 이유에 대해서 살펴볼 수 있을 것 같다.
### final
final은 `마지막의` 또는 `변경될 수 없는`의 의미를 가지고 있다. 또한 **클래스, 메서드, 멤버/지역 변수**에 사용할 수 있다. (사용범위가 넓음.)
- final 변수 : 변경할 수 없는 **상수 값**이 된다.
- final 메서드 : **오버라이딩(재정의)할 수 없는 메서드**가 된다.
- final 클래스 : 자신을 확장하는 자손(하위) 클래스를 정의할 수 없다. **상속이 불가능하다.**
### abstract
abstract는 `미완성`의 의미를 갖고 있다. 메서드를 선언만 하고 구현부를 작성하지 않는 **추상 메서드**에 사용된다.
- abstract void abc(); -> { } 구현부 블럭이 존재하지 않는다. abstract라는 제어자를 붙임으로써 가능한 것이다.
  - 추상 메서드임을 알려주는 제어자로, 클래스 내에 abstract가 붙은 메서드가 존재할 경우 그 클래스는 **추상 클래스**임을 확인할 수 있다.
    - 추상 클래스의 경우, 미완성(abstract)의 메서드가 존재하기 때문에 인스턴스를 생성할 수 없다.(new)

## 접근 제어자
접근 제어자(access modifier)는 일반 제어자와 마찬가지로 클래스, 변수, 메서드에 사용이 가능하다. 말그대로 접근을 제어하기 때문에
제어자에 따라 접근할 수 있는 영역이 달라진다. 만약 멤버 혹은 클래스에 접근 제어자가 없을 경우 이는 `default`이다.
### 접근 제어자 사용가능한 곳 : 클래스, 멤버변수, 메서드(+생성자)
1. private : **같은 클래스 내에서만** 접근이 가능하다.
2. default : **같은 패키지 내에서만** 접근이 가능하다.
3. protected : **같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서** 접근이 가능하다.
4. public : **접근 제한이 전혀 없다.**
- 위에서 부터 밑으로 내려가면서 점점 제한 범위가 확장된다. 패키지를 통해 클래스를 나눠놓는 것도 일종의 제한 범위를 설정하는 것과 같다.

## 캡슐화
캡슐화는 객체지향의 중요한 특성 중 하나이다. 캡슐화란 말 그대로 캡슐로 감싼다는 의미이다. 앞서 언급한 접근 제어자를 사용하면
마치 캡슐에 감싸져있는 형태로 데이터를 보호할 수 있다. 보호한다는 의미보다는 감춘다는 의미가 더 와닿을 수 있다. private 접근 제어자를 사용하면
같은 클래스 이외에 다른 클래스는 접근할 수 없다. 즉, 외부 클래스로부터 데이터를 감추게 되는 것이다. 뿐만 아니라
외부에서 접근할 필요가 없는 멤버에 대해서도 private으로 선언한다면 외부에 노출되는 멤버가 줄어든다. 이는 복잡성을 줄일 수 있게 된다.
### 캡슐화의 의미(접근 제어자를 사용하는 이유)
1. 외부로부터 데이터를 보호(감추기)하기 위해서
2. 외부에는 불필요한, 클래스 내에서만 사용되는 부분을 외부로 드러내지 않기 위해서

따라서 클래스를 설계하면서 멤버 변수에 private이 붙은 경우 외부 클래스에서는 접근을 못하는 것이 일반적이다. 이 때, 외부 클래스에서 접근할 수 있도록 하기 위해서
메서드를 설정하는데 이를 getter & setter라고 한다. 인텔리제이를 비롯한 IDE에서는 단축키를 통해 자동으로 생성이 가능하다.  
만약 클래스가 하위 클래스로 확장이 예상되는 클래스라면 멤버 변수에 private이 아닌 **protected**로 접근 제어자를 변경해야 한다. private의 경우 상속받은 하위 클래스에서는 접근할 수 없기 때문이다.

## 다형성
다형성이란 **여러 가지 형태를 가질 수 있는 능력**을 의미한다. **자바에서는 하나의 타입을 갖는 참조변수가 여러 타입의 인스턴스(객체)를 참조할 수 있다는 뜻이다.**
상속으로 예를 들자면, 상위 클래스 타입의 참조변수로 하위 클래스 타입의 인스턴스를 참조하였다는 것이다.(참조 : 실제 메모리 주소의 값을 변수에 저장)
```java
  class Tv {
    boolean power;
    int channel;
  }
  
  class SmartTv extends Tv {
    String text;
    void caption() {};
  }
```
위와 같은 상속 관계의 두 클래스가 있다고 했을 때 각각의 인스턴스를 다루기 위한 코드는  
```java
  Tv tv = new Tv();
  SmartTv stv = new SmartTv();
```
위와 같은 것이 일반적이고 직관적이다. 타입을 일치시키는 것은 크게 어려운 문제가 아니며 당연하게 여겨진다.
```java
  Tv tv = new SmartTv();
```
하지만 이처럼 참조변수 타입과 인스턴스의 타입이 일치하지 않는 경우는 우리에게 익숙하지 않다. 만약 Tv와 SmartTv의
상속 관계를 알지 못한다면 이 코드는 분명 잘못된 코드라고 판단할 것이다. 하지만 **다형성의 원리**에 따라 이 코드는 문법상 오류가 없다.
그 이유는 Tv라는 상위 클래스 타입은 하위 클래스 타입을 참조할 수 있기 때문이다.  

메모리 구조 상, **Tv가 차지하는 영역보다 SmartTv가 차지하는 영역이 더 많다.** 왜냐하면 SmartTv는 Tv의 멤버변수 2개에다가 
SmartTv의 멤버인 text와 caption 메서드까지 갖고 있기 때문이다. 즉, 상위 클래스 보다 하위 클래스의 메모리 영역이 더 클 수 밖에 없다.(정확히는 크거나 같다.)

다형성의 원칙에서는 **멤버 개수가 적은 타입이 멤버 개수가 많은 타입을 참조할 수 있다.** 상속으로 예를 들자면 멤버 개수가 적은 타입은
상위 클래스이며, 개수가 많은 타입은 하위 클래스이다. 따라서 위 코드처럼 `Tv tv = new SmartTv()`가 가능한 것이다. 하지만 반대인
`SmartTv stv = new Tv()`는 안된다. SmartTv 타입의 멤버 개수가 Tv보다 더 많기 때문이다.  

상위 클래스는 하위 클래스 인스턴스를 참조할 수 있다는 특징이 있지만, extends 즉 확장이라는 개념으로 봤을 때 하위 클래스가
다루는 영역이 훨씬 많다. 따라서 상위 클래스가 하위 클래스 타입을 참조한다는 것이 이해가 안될 수도 있다.(필자 또한 그랬다) double 타입을 매개변수로 받는 메서드에서 long 타입 인자를 넘길 경우, long 타입이 double 타입으로 자동 형변환 된다.
즉, 메모리 영역이 좁은 타입이 넓은 타입으로 변환하는 것은 큰 문제가 되지 않는다.(데이터가 손실되지 않음) 하지만 반대로 double이 long 타입으로 바뀐다면
즉, 메모리 영역이 넓은 타입에서 좁은 타입으로 가는 것은 데이터가 손실될 수 있다.  

이러한 관점에서 다형성을 바라보았을 때, `SmartTv stv = new Tv()`의 경우 Tv 타입이 SmartTv 타입으로 형변환 (좁은 타입에서 넓은 타입으로 변환)하는 것이라고 이해할 수 있다.
하지만 이는 기본형이 아닌 참조형이기 때문에 기본형의 형변환과는 조금 다른 메커니즘으로 봐야한다. 메모리 구조 상 SmartTv가 멤버 개수가 더 많기 때문에
메모리 상 차지하는 영역이 더 많다. 이때, Tv의 인스턴스를 참조할 경우 참조하는 공간이 남게 된다. 즉, 컴파일 에러가 발생할 수 밖에 없다.  

하지만 반대로 `Tv t = new SmartTv()`처럼 Tv 타입이 SmartTv보다 차지하는 메모리 영역이 적지만 SmartTv 인스턴스를 참조할 경우 메모리 영역이
남지는 않는다. 그저 SmartTv의 멤버들만 참조하지 못할 뿐이다. 따라서 컴파일상 문제가 없다.  

그런데 여기서 의문이 드는 점은 `Tv t = new SmartTv()`라고 하게 되면, 참조변수 t는 SmartTv 클래스의 멤버를 사용할 수 없게 된다.
그러면 왜 굳이 Tv 타입으로 선언하게 되는 것일까? **사실 상속의 관점으로 봤을 때, 이는 손해라고 생각할 수 있다.** 만약 참조변수 t를 통해
SmartTv의 멤버를 제어해야하는 상황이 오더라도 t는 할 수 없기 때문이다. 물론 Tv 타입의 참조변수 t를 SmartTv 타입으로 형변환하면 SmartTv의 멤버들을
사용할 수 있다.  

사실 다형성의 원리를 잘 활용한 예 중 하나인 인터페이스의 경우,
인터페이스의 추상메서드를 클래스가 구현(implements)하는 것이다. 따라서 연관관계에 있는 두 인터페이스와 클래스 간의 메서드 개수가 일치하게 된다.
따라서 상속에서의 다형성과는 다르게 사용할 수 있는 멤버의 영역에 손해가 발생하지 않는다. 거기에 다형성을 활용하는 이유 중 하나인
유지보수의 장점을 같이 누릴 수 있게 된다. 만약, Tv라는 클래스가 SmartTv와 더불어 CableTv를 상속하게 됐을 때, 또한 구현 코드에서
SmartTv를 CableTv로 바꿔야 한다면 우리는 기존의 `Tv t = new SmartTv()`를 `Tv t = new CableTv()`라고만 바꿔주면 된다. 그러면 여러 구현 코드에서는
Tv 타입으로 참조변수가 사용되었기 때문에 알아서 Tv 타입의 참조변수 t가 SmartTv가 아닌 CableTv 인스턴스를 참조하게 된다. 만약 모든 구현 코드에서 Tv 타입이 아닌 SmartTv 타입의 참조변수를 사용했다면
코드 하나하나를 다 SmartTv에서 CableTv로 바꿔줘야 한다. 사실 이 부분은 스프링에 대한 공부를 하다보면 쉽게 이해할 수 있는 부분이다.

## 참조변수의 형변환
참조변수의 경우 상속관계에 있는 클래스 사이에서는 형변환이 자유롭다. 하지만 형변환을 생략이 가능한 경우와 가능하지 않은 경우가 있다.
앞서 언급한 것처럼 기본형의 경우, 좁은 타입에서 넓은 타입으로 형변환하는 것은 크게 문제되지 않는다. (long -> double) 하지만 참조형의 형변환의 경우,
**넓은 타입에서 좁은 타입으로 형변환하는 것이 문제되지 않는다. (기본형과는 반대이다)** 왜냐하면 멤버가 많은 하위 클래스에서 멤버가 적은 상위 클래스로 변환하는 경우, 안전하기 때문이다.
반면에 상위 클래스에서 하위 클래스로 변환하려면 멤버를 담을 메모리 개수가 늘어나야 하기 때문에 안전하다고 할 수 없다. 따라서 이 경우에는 형변환 코드를 작성해야 한다.
```java
  class Car {}
  class FireEngine extends Car {}
  class Ambulance extends Car {}
```
위의 경우, Car와 FireEngine/Car와 Ambulance 간 형변환은 가능하다. 다만 FireEngine과 Ambulance 간 형변환은 불가능하다. (상위 클래스가 같을 뿐 둘은 서로 상속관계가 아니기 때문)
```java
  FireEngine f = new FireEngine();
  Car c = (Car)f; // 넓은 타입에서 좁은 타입으로 가는 경우, 메모리상 문제 없음 생략 가능
  FireEngine f2 = (FireEngine)c; // 좁은 타입(상위 클래스)에서 넓은 타입(하위 클래스)으로 가기 때문에 형변환 코드 생략 불가
```
위 코드에서 참조변수 f와 c는 가리키는 객체가 동일하다.(FireEngine 객체) 하지만 c 변수는 f 변수와 달리 사용할 수 있는 멤버 개수가 제한된다.
왜냐하면 하위 클래스 객체를 상위 클래스 타입으로 참조하였기 때문에 상위 클래스의 멤버만 사용할 수 있기 때문이다.  

즉, 참조변수의 형변환은 참조하는 인스턴스에 접근할 수 있는 멤버의 개수를 조절하는 것이다. 따라서 참조변수가 실제로 참조하는 인스턴스의 타입이 무엇인지를
파악한 뒤, 상황에 맞게 적절한 형변환을 취하는 것이 중요하다. 이 때 사용하는 연산자가 `instanceof` 연산자이다.

### instanceof 연산자
instanceof 연산자를 사용하는 이유는 뭘까? 그것은 바로 참조형의 경우 참조변수의 타입과 실제 인스턴스 타입이 일치하지 않을 수 있다는 특징이 있기 때문이다.
따라서 이 참조변수가 실제로 참조하는 인스턴스의 타입이 뭔지 직관적으로 알 방법이 없다. 이를 해결하기 위해 instanceof 연산자가 등장한 것이다.
```java
    void dowork(Car c){
        if (c instanceof FireEngine) {
            FireEngine fe = (FireEngine)c;
            fe.water();
        ...
        }
    }
```
위의 경우 매개변수로 들어온 Car 타입의 c 변수는 실제로 Car 타입의 인스턴스를 참조할 수도 있지만, 그의 하위 클래스 혹은 상위 클래스 타입의 인스턴스를 참조할 수도 있다.
만약 `c instanceof FireEngine`가 true라면, Car 타입의 참조변수로 FireEngine 인스턴스를 참조하고 있다는 뜻이다. 즉,
형변환을 하지 않으면 참조변수 c는 FireEngine의 멤버를 사용할 수가 없다. 따라서 참조변수 c가 사용할 수 있는 권한을 넓혀주기 위해서 형변환을 진행하는 것이다.
그리고 그러한 형변환을 진행하기에 앞서 실제 c가 참조하는 타입이 무엇인지 확인하는 작업이 필요한 것이다.

만약 c가 FireEngine이 아닌 Car 타입 인스턴스를 참조하고 있었다면 c를 형변환하면 안된다. (FireEngine c = new Car()는 안되기 때문)
따라서 형변환하기에 앞서 instanceof 연산자가 필요한 이유이다.

## 매개변수의 다형성
상속 파트에서 상위 클래스의 매개변수로 하위 클래스의 인스턴스를 참조할 수 있음을 배웠다. 즉, 상위 클래스 매개변수는
여러 하위 클래스를 참조할 수 있다는 뜻이며, **여러 인스턴스를 하나의 타입을 갖는 참조변수로 관리할 수 있다는 장점을 갖는다.**

이는 여러 타입의 인스턴스를 하나의 객체 배열로 관리할 때 사용될 수 있다. 배열은 기본적으로 같은 타입의 변수들을
관리할 수 있다. (String, Int, Char 등등) 여러 인스턴스 타입을 참조할 수 있는 상위 클래스 참조변수를 통해
**겉으로 봤을 때는 하나의 타입이지만, 각각의 인덱스가 서로 다른 인스턴스를 참조하는 것이 된다.**

### Vector 클래스
배열을 동적으로 관리할 수 있는 Vector 클래스가 자바에도 있다는 것을 알았다. C++에 동적 배열인 vector가 존재하는데
이와 같은 기능을 수행하는 것이 자바에도 동일한 이름으로 존재한다.

## 추상 클래스
추상 클래스는 일반 클래스와 다른게 딱 하나밖에 없다. 바로 **추상 메서드의 유무이다.** 추상 메서드란 선언부만 존재하고
구현부가 없는 메서드를 뜻한다. 즉, 어떤 클래스가 10개의 일반 메서드와 단 한 개의 추상 메서드를 갖고 있다면
그것은 **추상 클래스로 분류된다. 추상 클래스는 class 앞에 `abstract`를 붙힌다.**

추상 클래스의 진정한 의미는 상속으로부터 시작된다. 클래스를 일반적인 설계도라고 한다면, 추상 클래스는 좀 더
뭉퉁그려진, 보다 큰 그림을 그린 설계도인 것이다. 만약 이 설계도를 기반으로 여러 구체적인 설계도를 만들 수 있다면
추상적일지라도 그것의 역할이 분명하다고 할 수 있다. 자바에서의 추상 클래스도 이와 같다.

추상 클래스를 사용하면 여러 클래스의 공통적인 부분들을 관리할 수 있다. **상속**파트에서 배운 것처럼 각각의 하위 클래스가 공통적으로 갖는
멤버를 상위 클래스에서 관리할 수 있다. 마찬가지로 **추상 클래스는 상속 기능을 통해 구체화될 수 있는 멤버들을 관리하는 클래스이다.**

### 추상 클래스는 그 자체로 인스턴스화 될 수 없다.
추상 클래스(추상 메서드가 최소 1개)는 new 생성자를 통해 생성될 수 없다. 만약 추상 클래스의 추상 메서드가 전부
구현되지 않았다면 이 또한 인스턴스로 생성될 수 없다. **추상 클래스는 인스턴스로 활용하는 용도가 아니다.**

### 추상 클래스와 추상 메서드가 필요한 이유?
선언부만 있고, 구현부가 존재하지 않는 추상 메서드 그리고 이를 관리하는 추상 클래스가 도대체 무슨 의미가 있을까?
심지어 추상 클래스는 그 자체로 객체가 될 수 없기 때문에 더욱 의문이 생긴다. 하지만 클래스를 사용하는 입장에서 보았을 때
클래스에 구현된 내용을 자세하게 알 필요는 없다. **그저 어떠한 기능들이 있는지와 해당 기능을 사용할 수 있는 메서드의 선언부가 중요하다.**

C언어에서도 순차적으로 코드가 실행된다는 원리에 의해, 코드의 서론(?) 부분에 선언부만 작성하고, 구현부는 나중에 작성하는 것처럼
추상 클래스와 추상 메서드도 그러한 느낌으로 받아들이는게 필요할 것 같다.

또한 추상 메서드는 상속을 통해 구체화될 수 있다. 이는 추상 메서드가 상황에 따라 구현될 수 있는 폭이 무제한이라는 것이다.
추상 클래스와 추상 메서드를 통해 밑그림을 그려놓았다면, 이를 사용하는 개발자들은 자신의 상황에 맞게 해당 추상 메서드를 구현하면 된다는 장점이 있다.

### 추상 클래스의 근본은 상위 클래스이다.
추상 클래스가 존재한다면 이를 구현한 클래스들이 존재한다. 즉, 상속의 관점에서 이들은 상위 클래스와 하위 클래스로 분류된다.
즉, 추상 클래스(상위 클래스) 타입의 참조 변수로 구체화 클래스(하위 클래스) 타입의 인스턴스들을 참조할 수 있다는 뜻이다.

## 인터페이스
인터페이스도 일종의 추상 클래스이다. 하지만 추상 클래스보다 훨씬 더 **추상적이다.** 추상 클래스는 추상 메서드와 함께
일반 메서드도 가질 수 있다. 하지만 인터페이스는 오로지 **추상 메서드만 가질 수 있다.** 또한 멤버변수 또한 상수만 가질 수 있다.
추상 클래스와 구분하기 위해 class 대신 `interface`로 표시한다. 
- 모든 멤버변수는 `public static final`이며, 모든 메서드는 `public abstract`이다.
- 컴파일러를 통해 자동으로 추가가 되기 때문에 생략이 가능하다.
인터페이스는 **인터페이스를 다중상속**이 가능하다. 즉, 여러 인터페이스의 추상 메서드를 멤버로 가질 수 있다.

인터페이스도 추상 메서드를 가지기 때문에 이를 구현하는 것이 필요하다. 추상 클래스의 메서드를 구현하는 것과 구분하기 위해
`extends` 대신 `implements`를 사용한다. 상속은 extends, 인터페이스는 implements이기 때문에 클래스는 extends(상속)와 implements(구현)를 동시에 할 수 있다.

### 인터페이스의 다형성
자바의 다형성이 가장 많이 쓰이는 곳이 인터페이스이다. 인터페이스 타입의 참조변수로 구현한 여러 클래스의 인스턴스를 참조할 수 있다.
또한 인터페이스는 매개변수로 쓰이고, 반환타입으로도 쓰인다. **반환타입이 인터페이스라는 것은 해당 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것이다.**
즉, 인터페이스 타입의 매개변수로 쓰든, 반환타입으로 쓰든 실제로 값이 넘어가는 것은 구현한 클래스의 인스턴스 주소이다.

이처럼 인터페이스를 사용하면 보다 유연한 코드를 작성할 수 있다. 또한 인터페이스를 통해 클래스들을 간접적으로 연결하게 한다.
클래스가 서로 깊게 연관되어 있으면 나중에 코드를 수정할 때 번거로워진다. 따라서 인터페이스를 중간에 매개체로 두면
코드를 수정했을 때 다른 클래스가 영향을 받지 않는다.

또한 인터페이스는 구현부가 아닌 선언부로만 되어있기 때문에 인터페이스만 만들고, 바로 프로그램 개발이 가능하다.
실제로 인터페이스가 호출될 때는 구현 클래스가 사용되기 때문에 인터페이스의 구현 클래스가 추후에 완성되기만 하면 된다.

## 익명 클래스
익명 클래스는 new 생성자 안에 존재하는 클래스이다. `class` 명령어를 통해 생성되지는 않기 때문에 이름이 없다.
대신 클래스가 갖고 있는 멤버 및 메서드가 존재한다. 따라서 이름이 없는 클래스, 익명 클래스라고 하는 것이다. (이름은 없지만 있을 건 다 있는 느낌)

보통 익명 클래스는 람다식에서 많이 사용된다. 익명 클래스가 사용되는 이유는 클래스가 한 번만 사용되고 말거나, 굳이 이름이
필요 없는 경우가 있기 때문이다. 익명 클래스는 new 생성자 안에서 쓰이기 때문에 해당 인스턴스에 의해서만 사용된다.
따라서 쓰임에 따라 적절히 익명 클래스를 사용하면 코드를 간소화할 수 있다.