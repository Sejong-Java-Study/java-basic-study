# 객체지향 프로그래밍 II

1. [상속](#상속)
2. [오버라이딩](#오버라이딩)
3. [Super](#참조변수-super)
4. [제어자](#제어자)
   1. [static](#static)
   2. [final](#final)
   3. [abstract](#abstract)
5. [접근 제어자](#접근-제어자)
6. [캡슐화](#캡슐화)
7. [다형성](#다형성)
8. [참조변수 형변환](#참조변수의-형변환)


## 상속
프로그래밍에서의 상속은 extends, 확장한다는 의미이다. 상속을 사용하면 **코드를 재사용할 수 있고, 중복을 제거하여 생산성과 유지보수에 큰 기여를 한다.**
상속하는 클래스란 extends 대상인 상위 클래스를 뜻한다. 상속을 하게 되면, 상위 클래스의 멤버 변수를 그대로 갖고 있게 돼서, 상위 클래스보다 더 많은 멤버를 갖게 된다. (extends 의미)
하위 클래스의 인스턴스를 생성하면 상위 클래스 인스턴스를 생성하지 않고도 상속한 멤버들을 사용할 수 있다.

### (토의 주제) 하위 클래스 객체를 생성했을 때, 일어나는 JVM 메모리 변화 - 상위 클래스 객체를 생성하지 않고도 상위 클래스의 멤버를 사용할 수 있는 이유?

### 클래스 간의 관계 결정하기
클래스 들의 연관관계를 명확하게 함으로써 객체지향의 장점을 극대화해야 한다. 하나의 클래스에서 다른 클래스를 사용하는 경우
이는 **포함관계**로 코드를 재사용할 수 있다는 장점이 있다. 만약 포함이 아닌 상속을 사용한다고 해도 마찬가지로 코드의 재사용성이 높아진다.
하지만 포함관계와 상속관계는 의미가 다르다.
- 포함관계 : 두 클래스의 멤버는 서로 다른 영역이며, 공유될 수 없다.
- 상속관계 : 두 클래스의 멤버가 조상과 자손의 관계로, 조상의 멤버를 가진 상태로 확장될 수 있다.
클래스를 설계하면서 기존의 클래스 멤버를 가진 채 확장을 해야하는 클래스라면 **상속을 고려해볼 수 있다.**  
하지만 상속하지 않고도 다른 클래스를 사용할 수 있는 경우라면 **상속없이 포함관계로 설계할 수 있다.**(상속을 남용하지 않을 것)

### 단일 상속(Single Inheritance)
C++은 다중 상속이 가능하지만, 자바는 다중 상속이 불가능하다. 다중 상속이란 extends 대상이 두 개 이상인 경우이다.
다중 상속을 할 경우 여러 클래스들의 멤버를 가진 복합적인 클래스를 만들 수 있다는 장점이 있지만 그만큼 갖게 되는 멤버가
많아지기 때문에 클래스를 설계하는 과정에서 이름이 겹쳐서는 안된다. 또한 겹쳤을 경우, 이들을 구분하는 과정이 필요하다.
코드의 유지보수의 편의를 증대시키기 위한 자바의 선택은 단일 상속이다. **하나의 클래스만을 상속받게 되면 클래스 간 관계가
더욱 명확해지고, 코드를 더욱 신뢰할 수 있다는 장점이 있다.**

### 모든 클래스의 최상위 클래스 - Object
모든 클래스의 최상위 클래스는 Object이다. 따라서 모든 클래스가 toString(), equals() 같은 메서드를 바로 사용할 수 있는 것이다.
클래스가 상속한 대상이 없을 경우, 컴파일러가 자동으로 `extends Object`를 추가하여 Object로 상속받도록 한다.
> 만약 extends를 통해 상속한 대상이 있을 경우, 컴파일러가 `extends Object`를 추가하지는 않는다. (단일 상속 원칙)

## 오버라이딩
상속을 받게 되면 상위 클래스의 멤버 변수와 메서드를 그대로 물려 받는다. 이 때 상속받은 메서드의 이름과 반환타입, 매개변수를 그대로 유지한 채
구현부를 상황에 맞게 변경할 수 있다. 이를 재정의, Overriding이라고 한다. Override란 ~위에 덮어쓴다는 의미이다.

```java
class Point {
    int x;
    int y;

    String getLocation() {
        return "x :" + x + ", y :" + y;
    }
}

class Point3D extends Point {
    int z;

    @java.lang.Override
    String getLocation() {
        return "x :" + x + ", y :" + y + ", z :" + z;
    }
}
```
- Point3D 클래스는 Point 클래스를 상속받았기 때문에 Point 클래스의 멤버 변수와 메서드를 그대로 사용할 수 있을 것이라
  기대할 수 있다. 여기서 Override한 메서드를 사용할 때 예상할 수 있는 점은 **Point 클래스의 메서드의 특성과 연관관계가 있다는 것이다.**
  Point3D 클래스 내에 새롭게 메서드를 정의하는 것보다 코드에 의미를 부여하고, 클래스의 연관성을 잘 표현할 수 있다.

## 참조변수 super
클래스 내에서 자신의 멤버를 가리키는데 썼던 this와 마찬가지로 상속받은 멤버를 구분하는 데에 쓰이는 super라는 참조변수가 있다.
만약 상위클래스에 x라는 변수와 상속을 받은 하위클래스에서 x라는 변수가 있을 때, 상위 클래스의 x는 `super.s`, 하위 클래스의 x는 `this.s`로 구분된다.
또한 모든 인스턴스 메서드에는 this와 super가 지역변수로 존재한다. 여기에는 자신이 속한 인스턴스의 주소가 자동으로 저장된다.
**따라서 this와 super는 인스턴스의 주소를 가리키는 지역변수로 의미만 다를 뿐이다.**

## 생성자 super
가끔 어떠한 클래스를 들여다보게 되면 `super()`라는 생성자를 종종 보게 된다. 같은 클래스 내에서 다른 생성자(오버로딩)를 호출할 때 사용되었던 this()와 마찬가지로 super()는 상위 클래스의 생성자를 호출할 때 사용되는 코드이다.
super()가 많이 쓰이는 이유는 실제로 자바에 구현되어 있는 여러 클래스들이 서로 연관관계가 있는 것끼리 묶여있기 때문에 상속, 구현 등으로 이루어져 있다.
따라서 **클래스 내에서 직접 생성자를 만들기 보다 상위 클래스에 이미 구현되어 있는 생성자를 가져다 쓰는 경우가 많은 것이다.** `super()`
를 쓰게 되면 단순히 코드가 단순해지는 것을 넘어 클래스가 맡고 있는 멤버에 대해 책임을 지도록 할 수 있다.  
```java
  class Point {
    int x, y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
  }
  
  class Point3D extends Point {
    int z;
    
    // 하위 클래스에서 직접 상위 클래스 멤버를 초기화
    Point3D(int x, int y, int z){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    // super()를 사용함으로써 상위 클래스 멤버 초기화 작업을 직접 하지 않음.
    Point3D(int x, int y, int z){
        super(x,y); // 상속받은 멤버 x와 y는 super()를 사용함.
        this.z = z; // Point3D의 고유한 멤버인 z에 대한 초기화만을 직접 함.
    }
  }
```
- 상속받은 멤버에 대한 초기화 작업은 상위 클래스의 생성자를 이용하였다.(super()를 사용) 물론 하위 클래스에서 직접
  초기화할 수도 있지만, `super()`를 사용함으로써 상위 클래스의 멤버와 하위 클래스의 멤버를 구분할 수 있다. 위 코드에서
  `super()`를 사용하지 않은 생성자에서는 x,y,z 중 어느 것이 상위 클래스의 멤버인지 명확하게 보이지 않는다. 하지만
  `super()`를 사용한 **생성자의 경우 상위 클래스 멤버와 하위 클래스 멤버가 명확하게 코드로 확인이 된다. 이처럼 객체지향의 특성을
  사용하면 코드를 통해 역할과 의미를 한 눈에 이해할 수 있다는 장점이 있다.**

## 패키지
자바 혹은 스프링으로 작업을 하다보면 하나의 클래스만으로 기능을 구현하기란 쉽지 않다. 여러 클래스들이 독립적인 역할을
수행함과 동시에 비슷한 기능을 하는 클래스끼리 묶어주는 작업이 필요하다. 이렇게 디렉토리로 구분하게 되면 클래스를 보다
효율적으로 관리할 수 있다. 클래스의 묶음 단위를 **패키지**라고 한다.  
- 새롭게 알게된 점 : 클래스의 실제 이름에는 패키지 이름까지 포함된다. ex) String : java.lang.String  

따라서 같은 클래스 이름을 갖더라도 패키지가 다를 경우 다른 클래스로 구분이 된다는 것이다. 패키지는 물리적인 하나의 디렉토리이기 때문에
이 디렉토리(패키지)에 속한 클래스들의 이름에는 디렉토리(패키지) 이름이 포함되어야 한다.

### 클래스 소스파일 보는 법
교재에서는 rt.jar 파일을 통해 클래스 파일을 소개하고 있다. 교재는 자바 8버전이기 때문에 자바 11을 사용하는 경우 해당 파일이
안 보일 수 있다. 자바 11(JDK 11)의 경우, `Program Files/java/jdk-11/lib` 폴더 내에 있는 `src.zip` 파일을 통해 우리가 사용하는
자바 파일들을 확인할 수 있다. `java.base.java.lang` 폴더에 들어가면 String, StringBuffer 등의 파일들을 확인할 수 있다.  
![자바 소스 파일 사진](https://github.com/Sejong-Java-Study/java-basic-study/assets/70999462/9cdf26e7-f70a-4ded-b5f0-243a4aff471c)
> 사진에서도 알 수 있듯이 클래스 파일들이 전부 별도의 패키지(디렉토리) 안에 있는 것을 알 수 있다.

## 제어자
클래스의 멤버 변수 및 메서드에 제어자를 붙이는 경우가 많다. 제어자를 통해 데이터를 보호할 수 있으며, **객체지향의 핵심 중 하나인
캡슐화에도 큰 역할을 한다.**
### static
static은 `클래스의` 또는 `공통적인`의 의미를 갖고 있다. static이 붙은 변수 혹은 메서드는 인스턴스 생성과 상관없이
사용할 수 있기 때문에 인스턴스 멤버를 제어하지 않는 것이라면 static을 붙이는 것을 고려해볼 수 있다. 인스턴스를 생성하지
않고도 호출할 수 있기 때문에 편리하고 속도도 더 빠르다. static을 붙일지 안 붙일지 판단하는 기준은 **해당 인스턴스의 멤버
들을 사용하는 메서드 혹은 변수인지이다.** 앞으로 소스파일을 보면서 static이 붙은 멤버들을 볼 때마다 그 이유에 대해서 살펴볼 수 있을 것 같다.
### final
final은 `마지막의` 또는 `변경될 수 없는`의 의미를 가지고 있다. 또한 **클래스, 메서드, 멤버/지역 변수**에 사용할 수 있다. (사용범위가 넓음.)
- final 변수 : 변경할 수 없는 **상수 값**이 된다.
- final 메서드 : **오버라이딩(재정의)할 수 없는 메서드**가 된다.
- final 클래스 : 자신을 확장하는 자손(하위) 클래스를 정의할 수 없다. **상속이 불가능하다.**
### abstract
abstract는 `미완성`의 의미를 갖고 있다. 메서드를 선언만 하고 구현부를 작성하지 않는 **추상 메서드**에 사용된다.
- abstract void abc(); -> { } 구현부 블럭이 존재하지 않는다. abstract라는 제어자를 붙임으로써 가능한 것이다.
  - 추상 메서드임을 알려주는 제어자로, 클래스 내에 abstract가 붙은 메서드가 존재할 경우 그 클래스는 **추상 클래스**임을 확인할 수 있다.
    - 추상 클래스의 경우, 미완성(abstract)의 메서드가 존재하기 때문에 인스턴스를 생성할 수 없다.(new)

## 접근 제어자
접근 제어자(access modifier)는 일반 제어자와 마찬가지로 클래스, 변수, 메서드에 사용이 가능하다. 말그대로 접근을 제어하기 때문에
제어자에 따라 접근할 수 있는 영역이 달라진다. 만약 멤버 혹은 클래스에 접근 제어자가 없을 경우 이는 `default`이다.
### 접근 제어자 사용가능한 곳 : 클래스, 멤버변수, 메서드(+생성자)
1. private : **같은 클래스 내에서만** 접근이 가능하다.
2. default : **같은 패키지 내에서만** 접근이 가능하다.
3. protected : **같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서** 접근이 가능하다.
4. public : **접근 제한이 전혀 없다.**
- 위에서 부터 밑으로 내려가면서 점점 제한 범위가 확장된다. 패키지를 통해 클래스를 나눠놓는 것도 일종의 제한 범위를 설정하는 것과 같다.

## 캡슐화
캡슐화는 객체지향의 중요한 특성 중 하나이다. 캡슐화란 말 그대로 캡슐로 감싼다는 의미이다. 앞서 언급한 접근 제어자를 사용하면
마치 캡슐에 감싸져있는 형태로 데이터를 보호할 수 있다. 보호한다는 의미보다는 감춘다는 의미가 더 와닿을 수 있다. private 접근 제어자를 사용하면
같은 클래스 이외에 다른 클래스는 접근할 수 없다. 즉, 외부 클래스로부터 데이터를 감추게 되는 것이다. 뿐만 아니라
외부에서 접근할 필요가 없는 멤버에 대해서도 private으로 선언한다면 외부에 노출되는 멤버가 줄어든다. 이는 복잡성을 줄일 수 있게 된다.
### 캡슐화의 의미(접근 제어자를 사용하는 이유)
1. 외부로부터 데이터를 보호(감추기)하기 위해서
2. 외부에는 불필요한, 클래스 내에서만 사용되는 부분을 외부로 드러내지 않기 위해서

따라서 클래스를 설계하면서 멤버 변수에 private이 붙은 경우 외부 클래스에서는 접근을 못하는 것이 일반적이다. 이 때, 외부 클래스에서 접근할 수 있도록 하기 위해서
메서드를 설정하는데 이를 getter & setter라고 한다. 인텔리제이를 비롯한 IDE에서는 단축키를 통해 자동으로 생성이 가능하다.  
만약 클래스가 하위 클래스로 확장이 예상되는 클래스라면 멤버 변수에 private이 아닌 **protected**로 접근 제어자를 변경해야 한다. private의 경우 상속받은 하위 클래스에서는 접근할 수 없기 때문이다.

## 다형성
다형성이란 **여러 가지 형태를 가질 수 있는 능력**을 의미한다. **자바에서는 하나의 타입을 갖는 참조변수가 여러 타입의 인스턴스(객체)를 참조할 수 있다는 뜻이다.**
상속으로 예를 들자면, 상위 클래스 타입의 참조변수로 하위 클래스 타입의 인스턴스를 참조하였다는 것이다.(참조 : 실제 메모리 주소의 값을 변수에 저장)
```java
  class Tv {
    boolean power;
    int channel;
  }
  
  class SmartTv extends Tv {
    String text;
    void caption() {};
  }
```
위와 같은 상속 관계의 두 클래스가 있다고 했을 때 각각의 인스턴스를 다루기 위한 코드는  
```java
  Tv tv = new Tv();
  SmartTv stv = new SmartTv();
```
위와 같은 것이 일반적이고 직관적이다. 타입을 일치시키는 것은 크게 어려운 문제가 아니며 당연하게 여겨진다.
```java
  Tv tv = new SmartTv();
```
하지만 이처럼 참조변수 타입과 인스턴스의 타입이 일치하지 않는 경우는 우리에게 익숙하지 않다. 만약 Tv와 SmartTv의
상속 관계를 알지 못한다면 이 코드는 분명 잘못된 코드라고 판단할 것이다. 하지만 **다형성의 원리**에 따라 이 코드는 문법상 오류가 없다.
그 이유는 Tv라는 상위 클래스 타입은 하위 클래스 타입을 참조할 수 있기 때문이다.  

메모리 구조 상, **Tv가 차지하는 영역보다 SmartTv가 차지하는 영역이 더 많다.** 왜냐하면 SmartTv는 Tv의 멤버변수 2개에다가 
SmartTv의 멤버인 text와 caption 메서드까지 갖고 있기 때문이다. 즉, 상위 클래스 보다 하위 클래스의 메모리 영역이 더 클 수 밖에 없다.(정확히는 크거나 같다.)

다형성의 원칙에서는 **멤버 개수가 적은 타입이 멤버 개수가 많은 타입을 참조할 수 있다.** 상속으로 예를 들자면 멤버 개수가 적은 타입은
상위 클래스이며, 개수가 많은 타입은 하위 클래스이다. 따라서 위 코드처럼 `Tv tv = new SmartTv()`가 가능한 것이다. 하지만 반대인
`SmartTv stv = new Tv()`는 안된다. SmartTv 타입의 멤버 개수가 Tv보다 더 많기 때문이다.  

상위 클래스는 하위 클래스 인스턴스를 참조할 수 있다는 특징이 있지만, extends 즉 확장이라는 개념으로 봤을 때 하위 클래스가
다루는 영역이 훨씬 많다. 따라서 상위 클래스가 하위 클래스 타입을 참조한다는 것이 이해가 안될 수도 있다.(필자 또한 그랬다) double 타입을 매개변수로 받는 메서드에서 long 타입 인자를 넘길 경우, long 타입이 double 타입으로 자동 형변환 된다.
즉, 메모리 영역이 좁은 타입이 넓은 타입으로 변환하는 것은 큰 문제가 되지 않는다.(데이터가 손실되지 않음) 하지만 반대로 double이 long 타입으로 바뀐다면
즉, 메모리 영역이 넓은 타입에서 좁은 타입으로 가는 것은 데이터가 손실될 수 있다.  

이러한 관점에서 다형성을 바라보았을 때, `SmartTv stv = new Tv()`의 경우 Tv 타입이 SmartTv 타입으로 형변환 (좁은 타입에서 넓은 타입으로 변환)하는 것이라고 이해할 수 있다.
하지만 이는 기본형이 아닌 참조형이기 때문에 기본형의 형변환과는 조금 다른 메커니즘으로 봐야한다. 메모리 구조 상 SmartTv가 멤버 개수가 더 많기 때문에
메모리 상 차지하는 영역이 더 많다. 이때, Tv의 인스턴스를 참조할 경우 참조하는 공간이 남게 된다. 즉, 컴파일 에러가 발생할 수 밖에 없다.  

하지만 반대로 `Tv t = new SmartTv()`처럼 Tv 타입이 SmartTv보다 차지하는 메모리 영역이 적지만 SmartTv 인스턴스를 참조할 경우 메모리 영역이
남지는 않는다. 그저 SmartTv의 멤버들만 참조하지 못할 뿐이다. 따라서 컴파일상 문제가 없다.  

그런데 여기서 의문이 드는 점은 `Tv t = new SmartTv()`라고 하게 되면, 참조변수 t는 SmartTv 클래스의 멤버를 사용할 수 없게 된다.
그러면 왜 굳이 Tv 타입으로 선언하게 되는 것일까? **사실 상속의 관점으로 봤을 때, 이는 손해라고 생각할 수 있다.** 만약 참조변수 t를 통해
SmartTv의 멤버를 제어해야하는 상황이 오더라도 t는 할 수 없기 때문이다. 물론 Tv 타입의 참조변수 t를 SmartTv 타입으로 형변환하면 SmartTv의 멤버들을
사용할 수 있다.  

사실 다형성의 원리를 잘 활용한 예 중 하나인 인터페이스의 경우,
인터페이스의 추상메서드를 클래스가 구현(implements)하는 것이다. 따라서 연관관계에 있는 두 인터페이스와 클래스 간의 메서드 개수가 일치하게 된다.
따라서 상속에서의 다형성과는 다르게 사용할 수 있는 멤버의 영역에 손해가 발생하지 않는다. 거기에 다형성을 활용하는 이유 중 하나인
유지보수의 장점을 같이 누릴 수 있게 된다. 만약, Tv라는 클래스가 SmartTv와 더불어 CableTv를 상속하게 됐을 때, 또한 구현 코드에서
SmartTv를 CableTv로 바꿔야 한다면 우리는 기존의 `Tv t = new SmartTv()`를 `Tv t = new CableTv()`라고만 바꿔주면 된다. 그러면 여러 구현 코드에서는
Tv 타입으로 참조변수가 사용되었기 때문에 알아서 Tv 타입의 참조변수 t가 SmartTv가 아닌 CableTv 인스턴스를 참조하게 된다. 만약 모든 구현 코드에서 Tv 타입이 아닌 SmartTv 타입의 참조변수를 사용했다면
코드 하나하나를 다 SmartTv에서 CableTv로 바꿔줘야 한다. 사실 이 부분은 스프링에 대한 공부를 하다보면 쉽게 이해할 수 있는 부분이다.

## 참조변수의 형변환
참조변수의 경우 상속관계에 있는 클래스 사이에서는 형변환이 자유롭다. 하지만 형변환을 생략이 가능한 경우와 가능하지 않은 경우가 있다.
앞서 언급한 것처럼 기본형의 경우, 좁은 타입에서 넓은 타입으로 형변환하는 것은 크게 문제되지 않는다. (long -> double) 하지만 참조형의 형변환의 경우,
**넓은 타입에서 좁은 타입으로 형변환하는 것이 문제되지 않는다. (기본형과는 반대이다)** 왜냐하면 멤버가 많은 하위 클래스에서 멤버가 적은 상위 클래스로 변환하는 경우, 안전하기 때문이다.
반면에 상위 클래스에서 하위 클래스로 변환하려면 멤버를 담을 메모리 개수가 늘어나야 하기 때문에 안전하다고 할 수 없다. 따라서 이 경우에는 형변환 코드를 작성해야 한다.
```java
  class Car {}
  class FireEngine extends Car {}
  class Ambulance extends Car {}
```
위의 경우, Car와 FireEngine/Car와 Ambulance 간 형변환은 가능하다. 다만 FireEngine과 Ambulance 간 형변환은 불가능하다. (상위 클래스가 같을 뿐 둘은 서로 상속관계가 아니기 때문)
```java
  FireEngine f = new FireEngine();
  Car c = (Car)f; // 넓은 타입에서 좁은 타입으로 가는 경우, 메모리상 문제 없음 생략 가능
  FireEngine f2 = (FireEngine)c; // 좁은 타입(상위 클래스)에서 넓은 타입(하위 클래스)으로 가기 때문에 형변환 코드 생략 불가
```
위 코드에서 참조변수 f와 c는 가리키는 객체가 동일하다.(FireEngine 객체) 하지만 c 변수는 f 변수와 달리 사용할 수 있는 멤버 개수가 제한된다.
왜냐하면 하위 클래스 객체를 상위 클래스 타입으로 참조하였기 때문에 상위 클래스의 멤버만 사용할 수 있기 때문이다.  

즉, 참조변수의 형변환은 참조하는 인스턴스에 접근할 수 있는 멤버의 개수를 조절하는 것이다. 따라서 참조변수가 실제로 참조하는 인스턴스의 타입이 무엇인지를
파악한 뒤, 상황에 맞게 적절한 형변환을 취하는 것이 중요하다. 이 때 사용하는 연산자가 `instanceof` 연산자이다.

### instanceof 연산자
instanceof 연산자를 사용하는 이유는 뭘까? 그것은 바로 참조형의 경우 참조변수의 타입과 실제 인스턴스 타입이 일치하지 않을 수 있다는 특징이 있기 때문이다.
따라서 이 참조변수가 실제로 참조하는 인스턴스의 타입이 뭔지 직관적으로 알 방법이 없다. 이를 해결하기 위해 instanceof 연산자가 등장한 것이다.
```java
    void dowork(Car c){
        if (c instanceof FireEngine) {
            FireEngine fe = (FireEngine)c;
            fe.water();
        ...
        }
    }
```
위의 경우 매개변수로 들어온 Car 타입의 c 변수는 실제로 Car 타입의 인스턴스를 참조할 수도 있지만, 그의 하위 클래스 혹은 상위 클래스 타입의 인스턴스를 참조할 수도 있다.
만약 `c instanceof FireEngine`가 true라면, Car 타입의 참조변수로 FireEngine 인스턴스를 참조하고 있다는 뜻이다. 즉,
형변환을 하지 않으면 참조변수 c는 FireEngine의 멤버를 사용할 수가 없다. 따라서 참조변수 c가 사용할 수 있는 권한을 넓혀주기 위해서 형변환을 진행하는 것이다.
그리고 그러한 형변환을 진행하기에 앞서 실제 c가 참조하는 타입이 무엇인지 확인하는 작업이 필요한 것이다.

만약 c가 FireEngine이 아닌 Car 타입 인스턴스를 참조하고 있었다면 c를 형변환하면 안된다. (FireEngine c = new Car()는 안되기 때문)
따라서 형변환하기에 앞서 instanceof 연산자가 필요한 이유이다.
