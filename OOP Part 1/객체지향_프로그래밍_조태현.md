# 객체지향 프로그래밍 I

1. [객체지향 언어](#객체지향-언어)
2. [클래스와 객체](#클래스와-객체의-차이)
3. [객체의 생성과 사용](#객체의-생성과-사용)
4. [클래스가 사용되는 이유](#클래스가-사용되는-이유)
5. [메서드](#메서드)
    1. [return문](#return문)
6. [JVM Call Stack](#JVM-Call-Stack)
7. [Static](#Static)
8. [오버로딩/생성자](#오버로딩)
9. [변수의 초기화](#변수의-초기화)


## 객체지향 언어
- C언어를 공부하면서 모듈화의 중요성을 배웠다. 특정 로직을 수행하는 소스코드들을 별도로 나누어 관리함으로써 코드의 재사용성이 높아짐을 알 수 있었다.
- JAVA 또한 마찬가지로 코드의 재사용성을 높이고, 유지 보수가 용이하도록 하는 것을 지향하는 언어이다.
- 객체지향의 여러 이론을 학습하는 과정에서 **코드의 재사용성, 유지보수, 코드의 중복 여부** 이 세가지에 대해 생각하면서 공부한다면 객체지향 설계의 필요성에 대해 더욱 쉽게 이해할 수 있을 것이다.
    - 처음부터 객체지향 방식으로 코드를 작성하기 보단, 일단 코드를 짠 후에 객체지향 방식으로 개선하는 방향으로 코드를 수정하는 것이 **객체지향에 대해 분석하고, 설계하는 능력**을 기를 수 있는 길이다.

## 클래스와 객체의 차이
- 객체지향을 공부하면서 가장 많이 등장하는 용어임과 동시에 가장 혼동하기 쉬운 용어이기도 하다. 자바의 정석에서는 클래스와 객체를 다음과 같이 정의한다.
    - 클래스란 객체를 정의해놓은 것, **객체의 설계도(틀)**, 객체를 **생성**하는데 사용
    - 객체는 클래스에 정의된 대로 **생성**
- 객체를 Object라는 사전적 의미로만 생각하면, 형태가 존재하는 것으로 한정하기 쉽다. 하지만 프로그래밍에서의 객체란 형태가 존재하지 않으며, 정의되기 어려운 것에 대해서도 객체로 정의할 수 있다.
    - 객체란 **클래스를 통해 생성되어 메모리에 올라간 것**을 뜻한다.
        - 사용자가 정의한 클래스 이외에 I/O, 쓰레드, 네트워크 소켓 등 컴퓨터 자원을 활용하여 다양한 기능을 수행하는 데 있어서도 여러 클래스가 사용된다. 이들은 특정한 형태가 정해져 있지는 않지만(차, TV, 리모컨 등) 클래스를 토대로 생성되어 메모리에 올라가 작업을 수행한다.
        - 유형의 객체 : 책상, 의자, 자동차, TV와 같은 사물
        - 무형의 객체 : 수학공식, 프로그램 에러와 같은 논리나 개념
- **클래스는 객체를 사용하는 용도로, 설계도에 불과하다. 실제 프로그래밍에서 사용되는 것은 객체이다. 따라서 두 용어를 혼동하지 않기 위해서는 객체가 생성되는 프로세스를 이해해야 한다. 객체를 사용하기 위해서는 클래스를 작성한 후(객체에 대한 정의), 클래스로부터 객체를 생성해서 사용한다.**
    - 클래스를 제대로 정의해놓으면, 그 뒤로 객체를 생성하는 것은 쉽다. 따라서 객체를 생성하기 위해서는 클래스가 정의되어야 한다.

## 객체지향에서 자주 사용되는 용어 정리
1. 멤버 : 클래스(객체)의 기본적인 구성요소는 속성과 기능이다. 클래스와 객체를 같이 묶어서 설명한 이유는 객체의 속성과 기능은 클래스에서 정의한 속성과 기능이기 때문이다.
2. 속성 : 멤버 변수(variable)를 뜻한다. ex) `int channel, String color, boolean power`
3. 기능 : 메서드를 뜻한다. ex) `power(), channelUp(), channelDown()`
4. 인스턴스(instance) : 객체를 가리키는 용어이다. 어떠한 클래스를 통해 객체를 생성했을 때(인스턴스화), 그 객체를 **클래스의 인스턴스**라고 한다. 객체와 인스턴스 둘 다 같은 의미이지만, 상황에 따라 쓰이는 경우가 다르다.
    - 클래스와의 관계를 강조하는 경우 : a는 A라는 클래스의 인스턴스이다.
    - 포괄적으로 대상을 지칭하는 경우 : B는 클래스가 아닌 객체이다.

## 클래스 작성 규칙
1) 하나의 소스파일에 여러 개의 클래스가 있을 수 있으나, public class는 한 개만 존재해야 한다.
2) public class가 있는 경우, 소스파일 이름과 public class의 이름이 일치해야 한다.
3) public class가 없는 경우, 소스파일 이름은 아무 class와 매칭되어도 상관 없다.
    - 대소문자는 구분해서 작성해야 한다.

## 객체의 생성과 사용
- 클래스를 선언만 하는 것은 설계도 작성에 불과하다. 실제 프로그램에 사용하기 위해서는 객체(인스턴스)로 생성해야 한다.(메모리에 로드)
```java
    public static void main(String[]args){
        Tv t;
        t = new Tv();
        t.channel = 7;
        t.channelDown();
    }
    
    class Tv{
        // 클래스의 속성(멤버변수) 정의
        String color;
        boolean power;
        int channel;
        
        // 클래스의 기능(메서드) 정의
        void power() { power = !power; }
        void channelUp() { ++channel;}
        void channelDown() { --channel;}
    }
```
### 변수 선언에 따른 메모리 변화
1) (클래스 타입) 참조변수; - Tv t;
- 정의한 클래스 타입으로 참조변수를 선언하는 것이다. 이 때, 메모리에 참조변수를 위한 공간이 생성된다. 참조변수는 인스턴스의 주소를 가리키기 때문에 참조변수라고 하며, JVM 스택 영역에 저장된다.
2) (클래스 타입) 참조변수 = new 클래스 생성자(); - Tv t = new Tv();
- new 연산자를 사용하면 **힙 메모리에 생성한 인스턴스(객체)에 대한 메모리 공간이 생성된다.** 이 때, 생성되는 인스턴스는 클래스에서 정의한 속성(멤버 변수)을 기본 값으로 초기화하여 갖게 된다.
- 힙 영역 어딘가에 생성된 실제 인스턴스를 사용하기 위해서는 해당 주소값이 필요하다. 이 주소 값을 저장하는 변수가 1)에서 정의한 참조 변수이다.
    - 실제 인스턴스가 생성된 메모리(힙 영역)와 이 인스턴스의 주소 값을 갖는 참조변수(스택 영역)의 메모리 영역은 다르다.
- C언어의 포인터에서 데이터의 주소값을 알면 쉽게 제어가 가능하듯이, 자바에서도 마찬가지로 생성한 인스턴스에 대한 주소 값을 갖는 변수를 사용한다.
    - 참조변수를 사용하면, 참조변수를 통해 실제 인스턴스에 접근이 가능하고, 인스턴스가 갖고 있는 변수, 메서드 등에 접근이 가능하다. -> 인스턴스를 다루기 위해서는 **반드시 참조변수가 필요하다는 뜻이다.**
3) 참조변수를 사용하여 인스턴스의 변수, 메서드에 접근 - t.channel++, t.channelDown();
- `.`이라는 참조연산자를 사용하면 해당 인스턴스에 대해 접근이 가능하다. (C언어는 *)
- `.`을 사용하는 것은 실제 힙 메모리에 저장된 인스턴스 자원에 접근하는 것이다.
- **인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.**
    - 인스턴스의 주소 값을 저장하는 것이 참조 변수이므로, 참조 변수의 타입은 당연히 해당 인스턴스의 타입과 일치해야 한다.

## 객체 배열
- 배열은 프로그래밍 분야에서 많이 사용되는 자료구조 중 하나이다. 배열의 주요 특징은 여러 데이터 타입을 하나로 묶어서 저장할 수 있다는 것이다.
- 객체 또한 배열로 다룰 수 있으며, 배열에 저장되는 것은 **객체의 주소 값**이 저장된다. 객체의 주소 값을 저장하는 **참조 변수들을 배열로 저장하는 것이다.**
- 객체 배열을 생성하는 것은 참조변수를 생성하는 것이지, 실제 객체가 생성된 것이 아니다!(힙 메모리에 생성된 객체가 존재하지 않음)
    - 객체는 new 연산자를 통해서만 생성되기 때문에 객체 배열 요소(참조 변수)별로 객체를 생성해야 한다.
```java
    Tv[] tvArr = new Tv[3]; // Tv 타입의 객체 주소 값을 저장(참조)하는 참조 변수 배열 생성
    
    tvArr[0] = new Tv(); // 참조변수에 실제로 생성한 객체(인스턴스)의 주소 값 저장
```

- 객체 배열을 생성하는 과정이 실제 객체를 생성하는 코드와 유사(new 연산자 사용)하다 보니, 객체 배열과 객체가 동시에 생성되는 것이라 이해하기 쉽다.(필자도 초반에 많이 헷갈렸다.)

## 클래스가 사용되는 이유
- 프로그래밍 관점에서 클래스의 정의와 의미를 이해하는 것이 중요하다. 어쩌면 객체지향 프로그래밍에 대한 의구심을 해결할 수 있는 내용일 것 같다.
    - 데이터의 저장 형태의 발전은 변수 -> 배열 -> 구조체 -> 클래스 순으로 이어진다.
        - 변수의 경우 데이터(주소 값)를 저장하기 위해서, 그리고 같은 타입의 여러 변수들을 하나의 변수로 다루기 위해서 배열이 등장한다.
        - 타입에 상관없이 여러 자료들을 하나로 다루기 위해 구조체가 등장하였다. 그리고 이 데이터만을 다루는 구조체에 **함수까지 추가**된 것이 클래스이다.
            - 필자는 학교 수업으로 C언어, 자료구조 수업을 들으면서 C언어의 구조체(struct)를 사용하면서 이것이 클래스와 무엇이 다른지 의문이 들었다. 구조체의 경우 데이터만을 다루는 집합이기 때문에 데이터 간의 연간관계만 따질 수 있다는 단점이 있다.
        - 함수는 데이터를 가지고 작업을 하기 때문에 데이터(변수 값)와 관계가 상당히 깊다.
            - 자바는 서로 관련있는 기능을 수행하는 함수와 데이터를 하나의 클래스로 묶을 수 있다. 이는 기존의 C언어에서 기능별로 소스코드를 나누는 모듈화에서 한층 더 나아갔다고 생각한다.
                - C언어의 경우 문자열을 문자 배열(char[])로 다루지만, 자바의 경우 String이라는 하나의 클래스로 사용하게 된다. (이 String 클래스의 멤버 변수는 char[]이다.)
                - ```java
          public final class String
          implements java.io.Serializable, Comparable<String>, CharSequence,
                     Constable, ConstantDesc {
            @Stable
          private final byte[] value; // String 클래스의 멤버 변수
    
          // String 클래스의 함수(메서드) - 클래스 내의 변수를 메서드를 통해 다룬다.
          @Deprecated(since="1.1")
          public String(byte ascii[], int hibyte, int offset, int count) {
              checkBoundsOffCount(offset, count, ascii.length);
              if (count == 0) {
                  this.value = "".value;
                  this.coder = "".coder;
                  return;
              }
              if (COMPACT_STRINGS && (byte)hibyte == 0) {
                  this.value = Arrays.copyOfRange(ascii, offset, offset + count);
                  this.coder = LATIN1;
              } else {
                  hibyte <<= 8;
                  byte[] val = StringUTF16.newBytesFor(count);
                  for (int i = 0; i < count; i++) {
                      StringUTF16.putChar(val, i, hibyte | (ascii[offset++] & 0xff));
                  }
                  this.value = val;
                  this.coder = UTF16;
              }
          }
              ```
        - String이라는 클래스는 문자열과 관련된 변수와 함수(메서드)를 담는 공간이며, 문자열과 문자열에 필요한 함수들을 묶는다.
- 사용자가 직접 클래스를 정의하는 경우, 서로 다른 타입의 변수, 함수들을 하나의 클래스로 묶을 수 있다. 이렇게 되면 실제로는 관련이 없는 변수들에 관해서도 용도에 맞게 하나의 클래스로 묶음으로써 연관관계를 갖게 되는 것이다.

## 클래스의 변수
- 변수의 선언 위치에 따라 클래스 변수, 인스턴스 변수, 지역변수로 나뉘어 진다. 보통 클래스의 속성을 정의하는 멤버 변수는 클래스 변수와 인스턴스 변수로 나뉜다. 따라서 멤버변수와 멤버변수가 아닌 지역변수로 구분할 수 있다.
    - 멤버 변수의 경우, 클래스 영역에 선언되는 것을 말하고 지역 변수의 경우, 클래스 영역이 아닌 메서드(함수 내), 생성자, 매개변수 등에 선언되는 경우는 지역변수에 속한다.
- ```java
  class Variables {
    int iv;         // 인스턴스 변수
    static int cv;  // 클래스 변수(static 변수, 공유 변수)
    
    void method(){
      int iv = 0; // 지역 변수
    }
  ```
    - 위 예제의 경우처럼, 변수의 선언위치에 따라 클래스 변수와 지역 변수로 나뉘어진다.
1. 멤버 변수
    1. 인스턴스 변수
    - **클래스 영역**에 선언되며, 인스턴스(객체)를 생성하면 만들어진다. 따라서 **인스턴스가 생성되지 않으면 인스턴스 변수에 접근할 수 없다.** 인스턴스 변수는 각각의 인스턴스마다 별도의 저장공간을 갖고 있기 때문에 인스턴스마다 다른 값을 가질 수 있다.
    - 인스턴스마다 각기 다른 값을 가져야 하는 경우 인스턴스 변수로 선언한다.**(클래스 영역 내에서 별도의 제어자를 붙이지 않는다.)**
    2. 클래스 변수
    - 인스턴스 변수 앞에 **static**을 붙이면 클래스 변수가 된다. 마찬가지로 클래스 영역 내에서 선언된다. static인 멤버변수이기 때문에 클래스가 메모리에 로딩됐을 때 바로 사용이 가능하다. **(JVM 내에서 클래스 로더가 클래스를 메소드 영역에 로딩했을 때)**
        - `(클래스 이름).클래스 변수 ex) Tv.channel;`
    - 클래스 변수는 모든 인스턴스가 공통으로 공유하는 변수이기 때문에, **모든 인스턴스가 같은 값을 가져야 하는 경우 사용**한다.
2. 지역 변수
- 지역 변수의 가장 특징은 **메서드 내에서 선언되기 때문에 메서드가 종료되는 경우 변수 또한 소멸된다.**
- 메서드의 파라미터, 블럭(`{ }`) 내에 선언된 변수들의 종료 시점은 **메서드가 종료되는 시점**이다.

```java
    class Card {
        String kind;
        int number;
        
        static int width = 100;
        static int height = 250;
    }   
```
- 카드라는 클래스를 정의하였고, 각각의 카드마다 고유한 무늬와 숫자를 갖기 때문에, 클래스(Card)를 통해 생성된 각각의 인스턴스는 서로 다른 값을 가져야 한다. 따라서 이 부분은 인스턴스 변수로 선언한 것이다.
- 카드의 폭과 높이는 제각각이어서는 안된다. 따라서 Card의 인스턴스가 공통된 속성을 갖도록 하기 위한 부분은 static, 클래스 변수로 선언하였다.
    - **여기서 중요한 건, 클래스 변수가 각각의 인스턴스가 서로 공유하는 변수라는 것이다. 이는 즉, 클래스를 수정하였을 때, 생성된 인스턴스의 클래스 변수가 다 변경된다.** 카드의 폭과 높이가 변경되는 경우가 있으면, 클래스를 수정하면 모든 인스턴스의 공통 속성을 변경할 수 있는 것이다. 이는 객체지향의 특징 중 하나인 **유지보수**를 쉽게하는 것이다.
        - 클래스가 객체(인스턴스)의 설계도인 이유가 여기에 있다. 설계도를 기반으로 생성되는 객체가 갖는 공통적인 특성을 클래스를 통해 변경시킬 수 있는 것이다.
- 클래스 변수를 접근하는 방법은 `(인스턴스 참조 변수).클래스 변수` 혹은 `(클래스 타입).클래스 변수`인데, 후자의 방법을 권장한다.
    - 인스턴스 변수를 통해서 클래스 변수로 접근하면, 클래스 변수를 인스턴스 변수로 오해할 수 있기 때문이다. 코드를 봤을 때 직관적으로 이해할 수 있게 하려면, 클래스 변수를 변경하는 경우엔 클래스 타입으로 접근하도록 하자.

## 메서드
- 메서드는 작업을 수행하는 여러 코드들을 하나로 묶은 것이며, 입력값과 출력값이 반드시 있어야 하는 것은 아니다.
- 매개변수(Parameter) : 메서드를 선언했을 때, 메서드에 필요한 값을 제공받는 부분이다. **즉, 메서드를 구현하기 위해 사용되는 변수이다.**
- 인수(Argument) : 실제 메서드를 호출할 때, 전달되는 값을 뜻한다. 메서드에서 Argument로 전달하게 되면, **메서드가 호출되면서 Parameter에 Argument 값이 복사된다.**
    - 매개변수(Parameter) 및 메서드 내에서 구현되기 위해 사용되는 변수들은 전부 지역변수이다.
- 메서드가 호출되면, 이전에 실행되던 메서드는 잠시 멈추고, 호출된 메서드의 문장들이 실행된다. 호출된 메서드의 작업이 모두 끝나면 메서드를 호출했던 곳으로 다시 돌아온다. (스택)
- 전달되는 값(Argument)이 메서드에서 정의한 Parameter의 타입과 다를 경우, 자동 형변환이 된다면 상관 없다.
    - Argument : long 타입, Parameter : double 타입일 때, 전달받은 Argument long Type -> double Type (Implicit Casting)

### 메서드의 실행 흐름
```java
    static class MyMath {
        long add(long a, long b){
            long result = a + b;
            return result;
        }
    }

    public static void main(String[] args) {
        ...
        
        long value = MyMath.add(1L, 2L);
        
        ...
        
        long value2 = MyMath.add(1,2);
    }
```
1. main 메서드에서 add를 호출하게 되면 Argument인 1L과 2L이 add 메서드의 Parameter인 a와 b에 각각 복사된다.
2. add가 동작하는 데 있어서 사용되는 변수는 Argument 값이 복사된 Parameter이다.
3. add가 return문을 만남으로써 종료되고, 지역 변수인 a, b, result는 소멸된다.
4. value2의 경우, Argument는 int 타입이지만, 반환되는 값은 long 타입이다. int 타입이 long 타입으로 변환되는 것은 메모리 상 문제가 없기 때문에, add 메서드가 실행되는 과정에서 자동으로 형변환이 이루어진다.

### return문
- 메서드의 반환타입에 따라 return하는 데이터 타입이 달라진다. 특히, void의 경우 반환할 값이 없기 때문에 보통 return 문을 쓰지 않는다.
  하지만 **return문을 안써도 작동이 되는 것이지 return문이 없어도 되는 것은 아니다.** 반환형이 void일 때
  return문을 쓰지 않아도 되는 이유는 컴파일러가 자동으로 `return ;`을 추가하기 때문이다.
    - 따라서 메서드의 기본요소중 하나인 return 문은 메서드를 종료하고 메서드를 호출한 곳으로 다시 돌아가기 위해
      사용된다.
- if문의 경우에도 조건문에만 return을 작성하는 경우 에러가 발생한다. 그 이유는 해당 조건문이 실행되지 않을 경우가
  있기 때문이다. 따라서 else 혹은 추가로 return 문을 작성해야 한다.(메서드를 통해 값이 반환되도록 한다.)

## JVM Call Stack
- 호출스택이라고도 불리는 이 영역은, JVM 내 스택 영역에 존재한다. 스택은 먼저 들어온 녀석이 먼저 나가는
  FIFO 구조로, 자바 어플리케이션 실행 시 가장 먼저 실행되는 main 메서드가 맨 밑에 있게 된다.
  기본적으로 메서드의 동작원리르 설명하는 그림에서는 대부분 스택으로 되어 있으며, 이는 JVM Call Stack을 말하는 것이다.
  이 스택에는 메서드가 호출되었을 때, 연산의 결과, 지역변수 등에 대한 정보들도 저장되어 있다.

## Static
- 변수와 마찬가지로 메서드 또한 static을 붙일 수 있다. static을 붙이는 것은 인스턴스 변수 즉, 인스턴스를 생성함으로써 접근할 수 있는
  데이터가 아닌 일반 매개변수를 복사하여 동작할 수 있는 메서드라는 뜻이다. 따라서 static을 붙인 메서드를 호출할 때는
  `클래스 이름.메서드 이름` 이런 식으로 호출이 가능하다. 이 때 인스턴스 변수에 접근할 수 없기 때문에(객체를 생성하지 않았기 때문)
  상황에 따라 매개변수가 필요하다. 하지만 인스턴스 메서드의 경우 생성된 각각의 인스턴스의 변수들에 접근할 수 있기 때문에
  메서드의 입력인자에 매개변수가 없을 수도 있다.
- static이 있고 없고의 차이는 **인스턴스 변수가 없어도 동작이 가능한지이다.** 핵심은 static을 붙임으로써
  직접 객체(인스턴스)를 생성하지 않아도 된다는 것이다.

### Static을 붙이는 방법
1. 클래스를 설계할 때, 모든 인스턴스가 공통으로 사용하는 것은 static을 붙인다.
    - 인스턴스 변수의 경우 각 인스턴스마다 고유의 값을 유지한다. 만약 인스턴스가 모두 같은 값을
      유지해야 하는 경우에는 클래스 변수로 선언한다.(static)
    - 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다. static이 붙은 변수는
      클래스가 메모리에 올라갈 때(클래스 로더에 의해) 자동으로 생성되기 때문이다.
2. 클래스 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없다.
    - 클래스 메서드와 인스턴스 메서드(변수)의 호출 순서는 명확하게 알 수 있다.
      **클래스 메서드가 먼저 호출되고, 인스턴스 메서드가 그 다음에 호출이 되어야 한다.**
      왜냐하면 클래스 메서드는 인스턴스 생성에 관계없이 생성되지만 인스턴스 메서드는 반드시
      인스턴스가 생성되어야 사용할 수 있기 때문이다. 따라서 클래스 메서드가 인스턴스 메서드 및 변수를
      참조하거나 사용할 수는 없다.
    - 반대로 인스턴스 메서드(변수)는 클래스 변수 및 메서드를 참조/사용할 수 있다. 인스턴스 메서드(변수)를
      사용하는 시점에는 이미 클래스 변수 및 메서드가 생성되어 있기 때문이다.
3. 메서드 내에서 인스턴스 변수를 사용하지 않는 경우라면, static을 붙이는 것을 고려한다.
    - 인스턴스 변수를 처리해야하는 경우라면, static을 붙여선 안된다. 2번에서 설명한 것처럼
      클래스 메서드는 인스턴스 변수 및 메서드를 참조/사용할 수 없기 때문이다.(메모리 순서)
      하지만 인스턴스 변수와 관계가 없는 메서드라면, static을 붙여서 클래스 메서드로 선언하는 것을
      지향한다. 왜냐하면 static을 붙이면 클래스 로딩 시 생성되기 때문에 호출시간이 짧아지기 때문이다.
      인스턴스 메서드의 경우, 인스턴스가 생성되어야만 사용할 수 있기 때문에 메서드가 호출되는 과정에서
      탐색하는 추가 시간이 소요되기 때문이다.

## 오버로딩
- 생성자 및 메서드 등은 같은 이름을 가지지만 매개변수가 다를 경우 다르게 구별될 수 있다.
  오버로딩이 되기 위해서는 반환형으로 구분하지 않으며, **매개변수의 개수 또는 타입이 달라야 한다.**

## 생성자
- 생성자 또한 클래스 내에 속한 일종의 메서드이다. 일반적인 메서드와 구분되는 점은 반환타입이 없다는 것이다.(void 쓰지 않음)
  **인스턴스를 생성하는 것은 생성자가 아니다. new 이다.** 생성자는 인스턴스가 생성되었을 때 변수들을 초기화하는 메서드일뿐이다.
- 기본 생성자 : 자바 클래스에서 생성자를 작성하지 않을 경우, 컴파일러는 기본 생성자를 추가하여 컴파일한다.
  만약 클래스에 생성자를 만들었다면, 기본 생성자는 추가로 생성되지 않는다. 기본 생성자가 추가되는 경우는
  클래스에 정의된 생성자가 **하나도 없을 경우이다.**
### 생성자를 사용하면 좋은 점
- 생성자는 인스턴스가 생성되었을 때, 인스턴스 변수를 초기화하는 작업에 사용할 수 있다. 특히
  매개변수가 있는 생성자를 사용한다면 입력받은 값으로 바로 인스턴스 변수를 초기화 할 수 있다.
    - ```java
        // 매개변수가 없는 생성자를 사용했을 때
        Car c = new Car();
        c.color = "white";
        c.door = 4;
        
        // 매개변수가 있는 생성자를 사용했을 때
        Car c = new Car("white", 4);
    ```
        - 매개변수가 있는 생성자를 사용하면 훨씬 코드가 간결해지며, 변수를 초기화하는 과정이 간단하다.
### 생성자에서 다른 생성자를 호출하는 방법 - this()
- this()라는 코드 자체가 낯설기 때문에 처음 봤을 때 이것이 무슨 기능을 하는지 모를 수 있다.
  핵심은 생성자에서 다른 생성자를 호출할 때 **실제 생성자 이름(클래스 이름)을 사용하지 않고 this를 사용한다.**
  이러한 일이 일어나는 이유는 여러 생성자가 생성되는 오버로딩이 가능하기 때문이다. 예를 들어 Car라는 클래스의
  생성자는 Car()이다. 하지만 오버로딩한 생성자 Car(int a, int b) 안에서 기본 생성자인 Car()를 호출할 경우
  Car()가 아닌 this()를 사용한다.
- 한 생성자에서 다른 생성자를 호출 할 경우, this()는 맨 첫 줄에 사용해야 한다.
- ```java
    Car2(){
        this("white", "auto", 4);
    }
  
    Car2(String color, String gearType, int door){
        this.color = color;
        this.gearType = gearType;
        this.door = door;
    }
  ```
    - Car2 클래스의 기본 생성자를 호출할 경우, Car2의 오버로딩 메서드를 호출한다. 이 코드의 의미는
      기본 생성이 될 경우, `white, auto, 4`라는 인스턴스 변수를 갖는 객체가 생성된다. 즉, 매개변수를 넣지
      않는 경우, 생성되는 Default 옵션을 준 것이다. 코드를 굉장히 깔끔하게 짤 수 있는 기법이다. (this()를 사용)
    - 같은 클래스 내 오버로딩한 생성자들은 서로 관계가 깊은 경우가 많다. 따라서 이처럼 서로를 호출하도록 코드를
      작성한다면 유기적으로 연결된 좋은 코드를 작성할 수 있다. 또한 **수정이 필요한 경우 코드를 조금만 수정해도 된다는 점에서 유지보수가 쉬워진다.**
- 객체 자신을 가리키는 참조변수 this의 경우, 클래스 변수는 참조할 수 없다. static 메서드의 경우는 this를 사용할 수 없다. static의 경우 객체와 상관없이 생성되기 때문이다.

## 변수의 초기화
- 멤버변수(클래스 변수 및 인스턴스 변수)와 배열의 초기화는 필수가 아니다. 즉, 선언만 하더라도 자동으로 기본형으로 초기화 된다.
  따라서 초기화하지 않은 상태에서 멤버변수 간에 참조가 가능하다. 하지만 지역변수는 선언과 동시에 초기화가 자동으로 되지 않는다.
  따라서 **지역변수의 초기화는 필수이다.**

## 멤버변수의 초기화
- 멤버 변수가 초기화되는 순서는 클래스가 로딩될 때 클래스 변수가 초기화 된다. 그 다음 객체가 생성되면 인스턴스 변수가 초기화 된다.
- 클래스 내에 블럭({})을 사용하면 복잡한 멤버 변수의 초기화가 가능하다. 클래스 변수의 경우 블럭 앞에 static을 붙인다.
    - 클래스가 메모리에 로딩되면서 **클래스 초기화 블럭(static { })이 먼저 수행된다.** 그 다음 main 메서드가 실행되어,
      main 메서드 내에 있는 클래스 생성자가 호출되면 인스턴스가 생성되면서 **인스턴스 초기화 블럭이 수행된다.**
      초기화 블럭이 다 수행된 이후, 생성자가 수행된다.
        - 수행 순서 : 클래스 블럭 -> 인스턴스 블럭 -> 생성자