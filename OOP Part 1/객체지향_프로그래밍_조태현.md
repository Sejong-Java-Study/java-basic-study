# 객체지향 프로그래밍 I

1. [객체지향 언어](#객체지향-언어)  
2. [클래스와 객체](#클래스와-객체의-차이)  
3. [객체의 생성과 사용](#객체의-생성과-사용)  
4. [클래스가 사용되는 이유](#클래스가-사용되는-이유)
5. [메서드](#메서드)


## 객체지향 언어
- C언어를 공부하면서 모듈화의 중요성을 배웠다. 특정 로직을 수행하는 소스코드들을 별도로 나누어 관리함으로써 코드의 재사용성이 높아짐을 알 수 있었다.
- JAVA 또한 마찬가지로 코드의 재사용성을 높이고, 유지 보수가 용이하도록 하는 것을 지향하는 언어이다.
- 객체지향의 여러 이론을 학습하는 과정에서 **코드의 재사용성, 유지보수, 코드의 중복 여부** 이 세가지에 대해 생각하면서 공부한다면 객체지향 설계의 필요성에 대해 더욱 쉽게 이해할 수 있을 것이다.
  - 처음부터 객체지향 방식으로 코드를 작성하기 보단, 일단 코드를 짠 후에 객체지향 방식으로 개선하는 방향으로 코드를 수정하는 것이 **객체지향에 대해 분석하고, 설계하는 능력**을 기를 수 있는 길이다.

## 클래스와 객체의 차이
- 객체지향을 공부하면서 가장 많이 등장하는 용어임과 동시에 가장 혼동하기 쉬운 용어이기도 하다. 자바의 정석에서는 클래스와 객체를 다음과 같이 정의한다.
  - 클래스란 객체를 정의해놓은 것, **객체의 설계도(틀)**, 객체를 **생성**하는데 사용
  - 객체는 클래스에 정의된 대로 **생성**
- 객체를 Object라는 사전적 의미로만 생각하면, 형태가 존재하는 것으로 한정하기 쉽다. 하지만 프로그래밍에서의 객체란 형태가 존재하지 않으며, 정의되기 어려운 것에 대해서도 객체로 정의할 수 있다.
  - 객체란 **클래스를 통해 생성되어 메모리에 올라간 것**을 뜻한다.
    - 사용자가 정의한 클래스 이외에 I/O, 쓰레드, 네트워크 소켓 등 컴퓨터 자원을 활용하여 다양한 기능을 수행하는 데 있어서도 여러 클래스가 사용된다. 이들은 특정한 형태가 정해져 있지는 않지만(차, TV, 리모컨 등) 클래스를 토대로 생성되어 메모리에 올라가 작업을 수행한다.
    - 유형의 객체 : 책상, 의자, 자동차, TV와 같은 사물
    - 무형의 객체 : 수학공식, 프로그램 에러와 같은 논리나 개념
- **클래스는 객체를 사용하는 용도로, 설계도에 불과하다. 실제 프로그래밍에서 사용되는 것은 객체이다. 따라서 두 용어를 혼동하지 않기 위해서는 객체가 생성되는 프로세스를 이해해야 한다. 객체를 사용하기 위해서는 클래스를 작성한 후(객체에 대한 정의), 클래스로부터 객체를 생성해서 사용한다.**
  - 클래스를 제대로 정의해놓으면, 그 뒤로 객체를 생성하는 것은 쉽다. 따라서 객체를 생성하기 위해서는 클래스가 정의되어야 한다.

## 객체지향에서 자주 사용되는 용어 정리
1. 멤버 : 클래스(객체)의 기본적인 구성요소는 속성과 기능이다. 클래스와 객체를 같이 묶어서 설명한 이유는 객체의 속성과 기능은 클래스에서 정의한 속성과 기능이기 때문이다.
2. 속성 : 멤버 변수(variable)를 뜻한다. ex) `int channel, String color, boolean power`
3. 기능 : 메서드를 뜻한다. ex) `power(), channelUp(), channelDown()`
4. 인스턴스(instance) : 객체를 가리키는 용어이다. 어떠한 클래스를 통해 객체를 생성했을 때(인스턴스화), 그 객체를 **클래스의 인스턴스**라고 한다. 객체와 인스턴스 둘 다 같은 의미이지만, 상황에 따라 쓰이는 경우가 다르다.
   - 클래스와의 관계를 강조하는 경우 : a는 A라는 클래스의 인스턴스이다.
   - 포괄적으로 대상을 지칭하는 경우 : B는 클래스가 아닌 객체이다.

## 클래스 작성 규칙
1) 하나의 소스파일에 여러 개의 클래스가 있을 수 있으나, public class는 한 개만 존재해야 한다.
2) public class가 있는 경우, 소스파일 이름과 public class의 이름이 일치해야 한다.
3) public class가 없는 경우, 소스파일 이름은 아무 class와 매칭되어도 상관 없다.
    - 대소문자는 구분해서 작성해야 한다.

## 객체의 생성과 사용
- 클래스를 선언만 하는 것은 설계도 작성에 불과하다. 실제 프로그램에 사용하기 위해서는 객체(인스턴스)로 생성해야 한다.(메모리에 로드)
```java
    public static void main(String[]args){
        Tv t;
        t = new Tv();
        t.channel = 7;
        t.channelDown();
    }
    
    class Tv{
        // 클래스의 속성(멤버변수) 정의
        String color;
        boolean power;
        int channel;
        
        // 클래스의 기능(메서드) 정의
        void power() { power = !power; }
        void channelUp() { ++channel;}
        void channelDown() { --channel;}
    }
```
### 변수 선언에 따른 메모리 변화
1) (클래스 타입) 참조변수; - Tv t;
- 정의한 클래스 타입으로 참조변수를 선언하는 것이다. 이 때, 메모리에 참조변수를 위한 공간이 생성된다. 참조변수는 인스턴스의 주소를 가리키기 때문에 참조변수라고 하며, JVM 스택 영역에 저장된다.
2) (클래스 타입) 참조변수 = new 클래스 생성자(); - Tv t = new Tv();
- new 연산자를 사용하면 **힙 메모리에 생성한 인스턴스(객체)에 대한 메모리 공간이 생성된다.** 이 때, 생성되는 인스턴스는 클래스에서 정의한 속성(멤버 변수)을 기본 값으로 초기화하여 갖게 된다.
- 힙 영역 어딘가에 생성된 실제 인스턴스를 사용하기 위해서는 해당 주소값이 필요하다. 이 주소 값을 저장하는 변수가 1)에서 정의한 참조 변수이다.
  - 실제 인스턴스가 생성된 메모리(힙 영역)와 이 인스턴스의 주소 값을 갖는 참조변수(스택 영역)의 메모리 영역은 다르다.
- C언어의 포인터에서 데이터의 주소값을 알면 쉽게 제어가 가능하듯이, 자바에서도 마찬가지로 생성한 인스턴스에 대한 주소 값을 갖는 변수를 사용한다.
  - 참조변수를 사용하면, 참조변수를 통해 실제 인스턴스에 접근이 가능하고, 인스턴스가 갖고 있는 변수, 메서드 등에 접근이 가능하다. -> 인스턴스를 다루기 위해서는 **반드시 참조변수가 필요하다는 뜻이다.**
3) 참조변수를 사용하여 인스턴스의 변수, 메서드에 접근 - t.channel++, t.channelDown();
- `.`이라는 참조연산자를 사용하면 해당 인스턴스에 대해 접근이 가능하다. (C언어는 *)
- `.`을 사용하는 것은 실제 힙 메모리에 저장된 인스턴스 자원에 접근하는 것이다.
- **인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.**
    - 인스턴스의 주소 값을 저장하는 것이 참조 변수이므로, 참조 변수의 타입은 당연히 해당 인스턴스의 타입과 일치해야 한다.

## 객체 배열
- 배열은 프로그래밍 분야에서 많이 사용되는 자료구조 중 하나이다. 배열의 주요 특징은 여러 데이터 타입을 하나로 묶어서 저장할 수 있다는 것이다.
- 객체 또한 배열로 다룰 수 있으며, 배열에 저장되는 것은 **객체의 주소 값**이 저장된다. 객체의 주소 값을 저장하는 **참조 변수들을 배열로 저장하는 것이다.**
- 객체 배열을 생성하는 것은 참조변수를 생성하는 것이지, 실제 객체가 생성된 것이 아니다!(힙 메모리에 생성된 객체가 존재하지 않음)
  - 객체는 new 연산자를 통해서만 생성되기 때문에 객체 배열 요소(참조 변수)별로 객체를 생성해야 한다.
```java
    Tv[] tvArr = new Tv[3]; // Tv 타입의 객체 주소 값을 저장(참조)하는 참조 변수 배열 생성
    
    tvArr[0] = new Tv(); // 참조변수에 실제로 생성한 객체(인스턴스)의 주소 값 저장
```
- 객체 배열을 생성하는 과정이 실제 객체를 생성하는 코드와 유사(new 연산자 사용)하다 보니, 객체 배열과 객체가 동시에 생성되는 것이라 이해하기 쉽다.(필자도 초반에 많이 헷갈렸다.)

## 클래스가 사용되는 이유
- 프로그래밍 관점에서 클래스의 정의와 의미를 이해하는 것이 중요하다. 어쩌면 객체지향 프로그래밍에 대한 의구심을 해결할 수 있는 내용일 것 같다.
  - 데이터의 저장 형태의 발전은 변수 -> 배열 -> 구조체 -> 클래스 순으로 이어진다.
    - 변수의 경우 데이터(주소 값)를 저장하기 위해서, 그리고 같은 타입의 여러 변수들을 하나의 변수로 다루기 위해서 배열이 등장한다.
    - 타입에 상관없이 여러 자료들을 하나로 다루기 위해 구조체가 등장하였다. 그리고 이 데이터만을 다루는 구조체에 **함수까지 추가**된 것이 클래스이다.
      - 필자는 학교 수업으로 C언어, 자료구조 수업을 들으면서 C언어의 구조체(struct)를 사용하면서 이것이 클래스와 무엇이 다른지 의문이 들었다. 구조체의 경우 데이터만을 다루는 집합이기 때문에 데이터 간의 연간관계만 따질 수 있다는 단점이 있다.
    - 함수는 데이터를 가지고 작업을 하기 때문에 데이터(변수 값)와 관계가 상당히 깊다.
      - 자바는 서로 관련있는 기능을 수행하는 함수와 데이터를 하나의 클래스로 묶을 수 있다. 이는 기존의 C언어에서 기능별로 소스코드를 나누는 모듈화에서 한층 더 나아갔다고 생각한다.
        - C언어의 경우 문자열을 문자 배열(char[])로 다루지만, 자바의 경우 String이라는 하나의 클래스로 사용하게 된다. (이 String 클래스의 멤버 변수는 char[]이다.)
        - ```java
          public final class String
          implements java.io.Serializable, Comparable<String>, CharSequence,
                     Constable, ConstantDesc {
            @Stable
          private final byte[] value; // String 클래스의 멤버 변수
    
          // String 클래스의 함수(메서드) - 클래스 내의 변수를 메서드를 통해 다룬다.
          @Deprecated(since="1.1")
          public String(byte ascii[], int hibyte, int offset, int count) {
              checkBoundsOffCount(offset, count, ascii.length);
              if (count == 0) {
                  this.value = "".value;
                  this.coder = "".coder;
                  return;
              }
              if (COMPACT_STRINGS && (byte)hibyte == 0) {
                  this.value = Arrays.copyOfRange(ascii, offset, offset + count);
                  this.coder = LATIN1;
              } else {
                  hibyte <<= 8;
                  byte[] val = StringUTF16.newBytesFor(count);
                  for (int i = 0; i < count; i++) {
                      StringUTF16.putChar(val, i, hibyte | (ascii[offset++] & 0xff));
                  }
                  this.value = val;
                  this.coder = UTF16;
              }
          }
        ```
    - String이라는 클래스는 문자열과 관련된 변수와 함수(메서드)를 담는 공간이며, 문자열과 문자열에 필요한 함수들을 묶는다.
- 사용자가 직접 클래스를 정의하는 경우, 서로 다른 타입의 변수, 함수들을 하나의 클래스로 묶을 수 있다. 이렇게 되면 실제로는 관련이 없는 변수들에 관해서도 용도에 맞게 하나의 클래스로 묶음으로써 연관관계를 갖게 되는 것이다.

## 클래스의 변수
- 변수의 선언 위치에 따라 클래스 변수, 인스턴스 변수, 지역변수로 나뉘어 진다. 보통 클래스의 속성을 정의하는 멤버 변수는 클래스 변수와 인스턴스 변수로 나뉜다. 따라서 멤버변수와 멤버변수가 아닌 지역변수로 구분할 수 있다.
  - 멤버 변수의 경우, 클래스 영역에 선언되는 것을 말하고 지역 변수의 경우, 클래스 영역이 아닌 메서드(함수 내), 생성자, 매개변수 등에 선언되는 경우는 지역변수에 속한다.
- ```java
  class Variables {
    int iv;         // 인스턴스 변수
    static int cv;  // 클래스 변수(static 변수, 공유 변수)
    
    void method(){
      int iv = 0; // 지역 변수
    }
  ```
  - 위 예제의 경우처럼, 변수의 선언위치에 따라 클래스 변수와 지역 변수로 나뉘어진다.
1. 멤버 변수
   1. 인스턴스 변수
   - **클래스 영역**에 선언되며, 인스턴스(객체)를 생성하면 만들어진다. 따라서 **인스턴스가 생성되지 않으면 인스턴스 변수에 접근할 수 없다.** 인스턴스 변수는 각각의 인스턴스마다 별도의 저장공간을 갖고 있기 때문에 인스턴스마다 다른 값을 가질 수 있다.
   - 인스턴스마다 각기 다른 값을 가져야 하는 경우 인스턴스 변수로 선언한다.**(클래스 영역 내에서 별도의 제어자를 붙이지 않는다.)**
   2. 클래스 변수
   - 인스턴스 변수 앞에 **static**을 붙이면 클래스 변수가 된다. 마찬가지로 클래스 영역 내에서 선언된다. static인 멤버변수이기 때문에 클래스가 메모리에 로딩됐을 때 바로 사용이 가능하다. **(JVM 내에서 클래스 로더가 클래스를 메소드 영역에 로딩했을 때)**
     - `(클래스 이름).클래스 변수 ex) Tv.channel;`
   - 클래스 변수는 모든 인스턴스가 공통으로 공유하는 변수이기 때문에, **모든 인스턴스가 같은 값을 가져야 하는 경우 사용**한다.
2. 지역 변수
  - 지역 변수의 가장 특징은 **메서드 내에서 선언되기 때문에 메서드가 종료되는 경우 변수 또한 소멸된다.**
  - 메서드의 파라미터, 블럭(`{ }`) 내에 선언된 변수들의 종료 시점은 **메서드가 종료되는 시점**이다.

```java
    class Card {
        String kind;
        int number;
        
        static int width = 100;
        static int height = 250;
    }   
```
- 카드라는 클래스를 정의하였고, 각각의 카드마다 고유한 무늬와 숫자를 갖기 때문에, 클래스(Card)를 통해 생성된 각각의 인스턴스는 서로 다른 값을 가져야 한다. 따라서 이 부분은 인스턴스 변수로 선언한 것이다.
- 카드의 폭과 높이는 제각각이어서는 안된다. 따라서 Card의 인스턴스가 공통된 속성을 갖도록 하기 위한 부분은 static, 클래스 변수로 선언하였다.
  - **여기서 중요한 건, 클래스 변수가 각각의 인스턴스가 서로 공유하는 변수라는 것이다. 이는 즉, 클래스를 수정하였을 때, 생성된 인스턴스의 클래스 변수가 다 변경된다.** 카드의 폭과 높이가 변경되는 경우가 있으면, 클래스를 수정하면 모든 인스턴스의 공통 속성을 변경할 수 있는 것이다. 이는 객체지향의 특징 중 하나인 **유지보수**를 쉽게하는 것이다.
    - 클래스가 객체(인스턴스)의 설계도인 이유가 여기에 있다. 설계도를 기반으로 생성되는 객체가 갖는 공통적인 특성을 클래스를 통해 변경시킬 수 있는 것이다.
- 클래스 변수를 접근하는 방법은 `(인스턴스 참조 변수).클래스 변수` 혹은 `(클래스 타입).클래스 변수`인데, 후자의 방법을 권장한다.
  - 인스턴스 변수를 통해서 클래스 변수로 접근하면, 클래스 변수를 인스턴스 변수로 오해할 수 있기 때문이다. 코드를 봤을 때 직관적으로 이해할 수 있게 하려면, 클래스 변수를 변경하는 경우엔 클래스 타입으로 접근하도록 하자.

## 메서드
- 메서드는 작업을 수행하는 여러 코드들을 하나로 묶은 것이며, 입력값과 출력값이 반드시 있어야 하는 것은 아니다.
- 매개변수(Parameter) : 메서드를 선언했을 때, 메서드에 필요한 값을 제공받는 부분이다. **즉, 메서드를 구현하기 위해 사용되는 변수이다.**
- 인수(Argument) : 실제 메서드를 호출할 때, 전달되는 값을 뜻한다. 메서드에서 Argument로 전달하게 되면, **메서드가 호출되면서 Parameter에 Argument 값이 복사된다.**
  - 매개변수(Parameter) 및 메서드 내에서 구현되기 위해 사용되는 변수들은 전부 지역변수이다.
- 메서드가 호출되면, 이전에 실행되던 메서드는 잠시 멈추고, 호출된 메서드의 문장들이 실행된다. 호출된 메서드의 작업이 모두 끝나면 메서드를 호출했던 곳으로 다시 돌아온다. (스택)
- 전달되는 값(Argument)이 메서드에서 정의한 Parameter의 타입과 다를 경우, 자동 형변환이 된다면 상관 없다.
  - Argument : long 타입, Parameter : double 타입일 때, 전달받은 Argument long Type -> double Type (Implicit Casting)

### 메서드의 실행 흐름
```java
    static class MyMath {
        long add(long a, long b){
            long result = a + b;
            return result;
        }
    }

    public static void main(String[] args) {
        ...
        
        long value = MyMath.add(1L, 2L);
        
        ...
        
        long value2 = MyMath.add(1,2);
    }
```
1. main 메서드에서 add를 호출하게 되면 Argument인 1L과 2L이 add 메서드의 Parameter인 a와 b에 각각 복사된다.
2. add가 동작하는 데 있어서 사용되는 변수는 Argument 값이 복사된 Parameter이다.
3. add가 return문을 만남으로써 종료되고, 지역 변수인 a, b, result는 소멸된다.
4. value2의 경우, Argument는 int 타입이지만, 반환되는 값은 long 타입이다. int 타입이 long 타입으로 변환되는 것은 메모리 상 문제가 없기 때문에, add 메서드가 실행되는 과정에서 자동으로 형변환이 이루어진다.
